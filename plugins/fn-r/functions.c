/* This code was generated by generate.  Do not edit. */

#include <gnumeric-config.h>
#include <gnumeric.h>
#include <goffice/app/go-plugin.h>
#include <gnm-plugin.h>
#include <func.h>

#include <gnm-i18n.h>

#include <value.h>

#include <mathfunc.h>

GNM_PLUGIN_MODULE_HEADER;

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_dnorm[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.DNORM\n"
	   "@SYNTAX=R.DNORM(x,mu,sigma[,give_log])\n"
	   "@DESCRIPTION=R.DNORM function return the probability density function of the normal distribution.\n"
	   "\n"
	   "* @mu: mean of the distribution.\n"
	   "* @sigma: standard deviation of the distribution.\n"
	   "* @give_log: if true, log of the result will be returned instead.  This is useful if the result would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.PNORM,R.QNORM")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_dnorm (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float x = value_get_as_float (args[0]);
	gnm_float mu = value_get_as_float (args[1]);
	gnm_float sigma = value_get_as_float (args[2]);
	gboolean give_log = args[3] ? value_get_as_int (args[3]) : FALSE;

	return value_new_float (dnorm (x, mu, sigma, give_log));
}

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_pnorm[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.PNORM\n"
	   "@SYNTAX=R.PNORM(x,mu,sigma[,lower_tail,log_p])\n"
	   "@DESCRIPTION=R.PNORM function return the cumulative probability density function of the normal distribution.\n"
	   "\n"
	   "* @mu: mean of the distribution.\n"
	   "* @sigma: standard deviation of the distribution.\n"
	   "* @lower_tail: if true (the default), the lower tail of the distribution is considered.\n"
	   "* @log_p: if true, log of the probability is used.  This is useful if the probability would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.DNORM,R.QNORM")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_pnorm (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float x = value_get_as_float (args[0]);
	gnm_float mu = value_get_as_float (args[1]);
	gnm_float sigma = value_get_as_float (args[2]);
	gboolean lower_tail = args[3] ? value_get_as_int (args[3]) : TRUE;
	gboolean log_p = args[4] ? value_get_as_int (args[4]) : FALSE;

	return value_new_float (pnorm (x, mu, sigma, lower_tail, log_p));
}

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_qnorm[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.QNORM\n"
	   "@SYNTAX=R.QNORM(p,mu,sigma[,lower_tail,log_p])\n"
	   "@DESCRIPTION=R.QNORM function return the probability quantile function of the normal distribution.\n"
	   "\n"
	   "* @p: probability.\n"
	   "* @mu: mean of the distribution.\n"
	   "* @sigma: standard deviation of the distribution.\n"
	   "* @lower_tail: if true (the default), the lower tail of the distribution is considered.\n"
	   "* @log_p: if true, log of the probability is used.  This is useful if the probability would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.DNORM,R.PNORM")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_qnorm (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float p = value_get_as_float (args[0]);
	gnm_float mu = value_get_as_float (args[1]);
	gnm_float sigma = value_get_as_float (args[2]);
	gboolean lower_tail = args[3] ? value_get_as_int (args[3]) : TRUE;
	gboolean log_p = args[4] ? value_get_as_int (args[4]) : FALSE;

	return value_new_float (qnorm (p, mu, sigma, lower_tail, log_p));
}

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_plnorm[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.PLNORM\n"
	   "@SYNTAX=R.PLNORM(x,logmean,logsd[,lower_tail,log_p])\n"
	   "@DESCRIPTION=R.PLNORM function return the cumulative probability density function of the log-normal distribution.\n"
	   "\n"
	   "* @logmean: logarithm of the mean of the distribution.\n"
	   "* @logsd: logarithm of the standard deviation of the distribution.\n"
	   "* @lower_tail: if true (the default), the lower tail of the distribution is considered.\n"
	   "* @log_p: if true, log of the probability is used.  This is useful if the probability would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.DLNORM,R.QLNORM")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_plnorm (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float x = value_get_as_float (args[0]);
	gnm_float logmean = value_get_as_float (args[1]);
	gnm_float logsd = value_get_as_float (args[2]);
	gboolean lower_tail = args[3] ? value_get_as_int (args[3]) : TRUE;
	gboolean log_p = args[4] ? value_get_as_int (args[4]) : FALSE;

	return value_new_float (plnorm (x, logmean, logsd, lower_tail, log_p));
}

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_qlnorm[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.QLNORM\n"
	   "@SYNTAX=R.QLNORM(x,logmean,logsd[,lower_tail,log_p])\n"
	   "@DESCRIPTION=R.QLNORM function return the probability quantile function of the log-normal distribution.\n"
	   "\n"
	   "* @logmean: logarithm of the mean of the distribution.\n"
	   "* @logsd: logarithm of the standard deviation of the distribution.\n"
	   "* @lower_tail: if true (the default), the lower tail of the distribution is considered.\n"
	   "* @log_p: if true, log of the probability is used.  This is useful if the probability would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.DLNORM,R.PLNORM")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_qlnorm (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float x = value_get_as_float (args[0]);
	gnm_float logmean = value_get_as_float (args[1]);
	gnm_float logsd = value_get_as_float (args[2]);
	gboolean lower_tail = args[3] ? value_get_as_int (args[3]) : TRUE;
	gboolean log_p = args[4] ? value_get_as_int (args[4]) : FALSE;

	return value_new_float (qlnorm (x, logmean, logsd, lower_tail, log_p));
}

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_dgamma[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.DGAMMA\n"
	   "@SYNTAX=R.DGAMMA(x,shape,scale[,give_log])\n"
	   "@DESCRIPTION=R.DGAMMA function return the probability density function of the gamma distribution.\n"
	   "\n"
	   "* @shape: the shape parameter of the distribution\n"
	   "* @scale: the scale parameter of the distribution\n"
	   "* @give_log: if true, log of the result will be returned instead.  This is useful if the result would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.PGAMMA,R.QGAMMA")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_dgamma (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float x = value_get_as_float (args[0]);
	gnm_float shape = value_get_as_float (args[1]);
	gnm_float scale = value_get_as_float (args[2]);
	gboolean give_log = args[3] ? value_get_as_int (args[3]) : FALSE;

	return value_new_float (dgamma (x, shape, scale, give_log));
}

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_pgamma[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.PGAMMA\n"
	   "@SYNTAX=R.PGAMMA(x,p,scale[,lower_tail,log_p])\n"
	   "@DESCRIPTION=R.PGAMMA function return the cumulative probability density function of the gamma distribution.\n"
	   "\n"
	   "* @p: probability.\n"
	   "* @scale: the scale parameter of the distribution\n"
	   "* @lower_tail: if true (the default), the lower tail of the distribution is considered.\n"
	   "* @log_p: if true, log of the probability is used.  This is useful if the probability would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.DGAMMA,R.QGAMMA")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_pgamma (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float x = value_get_as_float (args[0]);
	gnm_float p = value_get_as_float (args[1]);
	gnm_float scale = value_get_as_float (args[2]);
	gboolean lower_tail = args[3] ? value_get_as_int (args[3]) : TRUE;
	gboolean log_p = args[4] ? value_get_as_int (args[4]) : FALSE;

	return value_new_float (pgamma (x, p, scale, lower_tail, log_p));
}

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_qgamma[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.QGAMMA\n"
	   "@SYNTAX=R.QGAMMA(p,alpha,scale[,lower_tail,log_p])\n"
	   "@DESCRIPTION=R.QGAMMA function return the probability quantile function of the gamma distribution.\n"
	   "\n"
	   "* @p: probability.\n"
	   "* @scale: the scale parameter of the distribution\n"
	   "* @lower_tail: if true (the default), the lower tail of the distribution is considered.\n"
	   "* @log_p: if true, log of the probability is used.  This is useful if the probability would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.DGAMMA,R.PGAMMA")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_qgamma (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float p = value_get_as_float (args[0]);
	gnm_float alpha = value_get_as_float (args[1]);
	gnm_float scale = value_get_as_float (args[2]);
	gboolean lower_tail = args[3] ? value_get_as_int (args[3]) : TRUE;
	gboolean log_p = args[4] ? value_get_as_int (args[4]) : FALSE;

	return value_new_float (qgamma (p, alpha, scale, lower_tail, log_p));
}

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_dbeta[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.DBETA\n"
	   "@SYNTAX=R.DBETA(x,a,b[,give_log])\n"
	   "@DESCRIPTION=R.DBETA function return the probability density function of the beta distribution.\n"
	   "\n"
	   "* @a: the first shape parameter of the distribution\n"
	   "* @b: the second scale parameter of the distribution\n"
	   "* @give_log: if true, log of the result will be returned instead.  This is useful if the result would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.PBETA,R.QBETA")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_dbeta (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float x = value_get_as_float (args[0]);
	gnm_float a = value_get_as_float (args[1]);
	gnm_float b = value_get_as_float (args[2]);
	gboolean give_log = args[3] ? value_get_as_int (args[3]) : FALSE;

	return value_new_float (dbeta (x, a, b, give_log));
}

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_pbeta[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.PBETA\n"
	   "@SYNTAX=R.PBETA(x,a,b[,lower_tail,log_p])\n"
	   "@DESCRIPTION=R.PBETA function return the cumulative probability density function of the beta distribution.\n"
	   "\n"
	   "* @a: the first shape parameter of the distribution\n"
	   "* @b: the second scale parameter of the distribution\n"
	   "* @lower_tail: if true (the default), the lower tail of the distribution is considered.\n"
	   "* @log_p: if true, log of the probability is used.  This is useful if the probability would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.DBETA,R.QBETA")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_pbeta (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float x = value_get_as_float (args[0]);
	gnm_float a = value_get_as_float (args[1]);
	gnm_float b = value_get_as_float (args[2]);
	gboolean lower_tail = args[3] ? value_get_as_int (args[3]) : TRUE;
	gboolean log_p = args[4] ? value_get_as_int (args[4]) : FALSE;

	return value_new_float (pbeta (x, a, b, lower_tail, log_p));
}

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_qbeta[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.QBETA\n"
	   "@SYNTAX=R.QBETA(alpha,a,b[,lower_tail,log_p])\n"
	   "@DESCRIPTION=R.QBETA function return the probability quantile function of the beta distribution.\n"
	   "\n"
	   "* @a: the first shape parameter of the distribution\n"
	   "* @b: the second scale parameter of the distribution\n"
	   "* @lower_tail: if true (the default), the lower tail of the distribution is considered.\n"
	   "* @log_p: if true, log of the probability is used.  This is useful if the probability would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.DBETA,R.PBETA")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_qbeta (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float alpha = value_get_as_float (args[0]);
	gnm_float a = value_get_as_float (args[1]);
	gnm_float b = value_get_as_float (args[2]);
	gboolean lower_tail = args[3] ? value_get_as_int (args[3]) : TRUE;
	gboolean log_p = args[4] ? value_get_as_int (args[4]) : FALSE;

	return value_new_float (qbeta (alpha, a, b, lower_tail, log_p));
}

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_dt[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.DT\n"
	   "@SYNTAX=R.DT(x,n[,give_log])\n"
	   "@DESCRIPTION=R.DT function return the probability density function of the Student t distribution.\n"
	   "\n"
	   "* @n: the number of degrees of freedom of the distribution\n"
	   "* @give_log: if true, log of the result will be returned instead.  This is useful if the result would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.PT,R.QT")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_dt (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float x = value_get_as_float (args[0]);
	gnm_float n = value_get_as_float (args[1]);
	gboolean give_log = args[2] ? value_get_as_int (args[2]) : FALSE;

	return value_new_float (dt (x, n, give_log));
}

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_pt[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.PT\n"
	   "@SYNTAX=R.PT(x,n[,lower_tail,log_p])\n"
	   "@DESCRIPTION=R.PT function return the cumulative probability density function of the Student t distribution.\n"
	   "\n"
	   "* @n: the number of degrees of freedom of the distribution\n"
	   "* @lower_tail: if true (the default), the lower tail of the distribution is considered.\n"
	   "* @log_p: if true, log of the probability is used.  This is useful if the probability would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.DT,R.QT")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_pt (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float x = value_get_as_float (args[0]);
	gnm_float n = value_get_as_float (args[1]);
	gboolean lower_tail = args[2] ? value_get_as_int (args[2]) : TRUE;
	gboolean log_p = args[3] ? value_get_as_int (args[3]) : FALSE;

	return value_new_float (pt (x, n, lower_tail, log_p));
}

/* ------------------------------------------------------------------------- */


static GnmFuncHelp const help_r_qt[] = {
	{ GNM_FUNC_HELP_OLD,
	F_("@FUNCTION=R.QT\n"
	   "@SYNTAX=R.QT(p,n[,lower_tail,log_p])\n"
	   "@DESCRIPTION=R.QT function return the probability quantile function of the Student t distribution.\n"
	   "\n"
	   "* @p: probability.\n"
	   "* @n: the number of degrees of freedom of the distribution\n"
	   "* @lower_tail: if true (the default), the lower tail of the distribution is considered.\n"
	   "* @log_p: if true, log of the probability is used.  This is useful if the probability would otherwise underflow to 0.  Defaults to false.\n"
	   "\n"
	   "@EXAMPLES=\n"
	   "\n"
	   "@SEEALSO=R.DT,R.PT")
	},
	{ GNM_FUNC_HELP_END }
};

static GnmValue *
gnumeric_r_qt (FunctionEvalInfo *ei, GnmValue **args)
{
	gnm_float p = value_get_as_float (args[0]);
	gnm_float n = value_get_as_float (args[1]);
	gboolean lower_tail = args[2] ? value_get_as_int (args[2]) : TRUE;
	gboolean log_p = args[3] ? value_get_as_int (args[3]) : FALSE;

	return value_new_float (qt (p, n, lower_tail, log_p));
}

/* ------------------------------------------------------------------------- */


GnmFuncDescriptor const stat_functions[] = {
	{
		"r.dnorm",
		"fff|f",
		N_("x,mu,sigma,give_log"),
		help_r_dnorm,
		gnumeric_r_dnorm, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{
		"r.pnorm",
		"fff|ff",
		N_("x,mu,sigma,lower_tail,log_p"),
		help_r_pnorm,
		gnumeric_r_pnorm, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{
		"r.qnorm",
		"fff|ff",
		N_("p,mu,sigma,lower_tail,log_p"),
		help_r_qnorm,
		gnumeric_r_qnorm, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{
		"r.plnorm",
		"fff|ff",
		N_("x,logmean,logsd,lower_tail,log_p"),
		help_r_plnorm,
		gnumeric_r_plnorm, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{
		"r.qlnorm",
		"fff|ff",
		N_("x,logmean,logsd,lower_tail,log_p"),
		help_r_qlnorm,
		gnumeric_r_qlnorm, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{
		"r.dgamma",
		"fff|f",
		N_("x,shape,scale,give_log"),
		help_r_dgamma,
		gnumeric_r_dgamma, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{
		"r.pgamma",
		"fff|ff",
		N_("x,p,scale,lower_tail,log_p"),
		help_r_pgamma,
		gnumeric_r_pgamma, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{
		"r.qgamma",
		"fff|ff",
		N_("p,alpha,scale,lower_tail,log_p"),
		help_r_qgamma,
		gnumeric_r_qgamma, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{
		"r.dbeta",
		"fff|f",
		N_("x,a,b,give_log"),
		help_r_dbeta,
		gnumeric_r_dbeta, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{
		"r.pbeta",
		"fff|ff",
		N_("x,a,b,lower_tail,log_p"),
		help_r_pbeta,
		gnumeric_r_pbeta, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{
		"r.qbeta",
		"fff|ff",
		N_("alpha,a,b,lower_tail,log_p"),
		help_r_qbeta,
		gnumeric_r_qbeta, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{
		"r.dt",
		"ff|f",
		N_("x,n,give_log"),
		help_r_dt,
		gnumeric_r_dt, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{
		"r.pt",
		"ff|ff",
		N_("x,n,lower_tail,log_p"),
		help_r_pt,
		gnumeric_r_pt, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{
		"r.qt",
		"ff|ff",
		N_("p,n,lower_tail,log_p"),
		help_r_qt,
		gnumeric_r_qt, NULL, NULL, NULL, NULL,
		GNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,
	},
	{ NULL }
};
