#!/usr/bin/perl -w
# -----------------------------------------------------------------------------

use strict;
$| = 1;

sub distribution;

my %funcs = ();
my %argoverride = ();

{
    my $of = "of the distribution";
    my @common = ('give_log' =>
	      "if true, log of the result will be returned instead.  " .
	      "This is useful if the result would otherwise underflow to 0.  " .
	      "Defaults to false.",
	      
	      'lower_tail' =>
	      "if true (the default), the lower tail of the distribution is considered.",

	      'log_p' => "if true, log of the probability is used.  " .
	      "This is useful if the probability would otherwise underflow to 0.  " .
	      "Defaults to false.",

	      'p' => 'probability.'
	      );

    $funcs{'dnorm'} = $funcs{'pnorm'} = $funcs{'qnorm'} =
	[\&distribution,
	 'normal',
	 ({ 'mu' => "mean $of.",
	    'sigma' => "standard deviation $of.",
	    @common })];

    $funcs{'dlnorm'} = $funcs{'plnorm'} = $funcs{'qlnorm'} =
	[\&distribution,
	 'log-normal',
	 ({ 'logmean' => "logarithm of the mean $of.",
	    'logsd' => "logarithm of the standard deviation $of.",
	    @common })];

    $funcs{'dgamma'} = $funcs{'pgamma'} = $funcs{'qgamma'} =
	[\&distribution,
	 'gamma',
	 ({ 'shape' => "the shape parameter $of",
	    'scale' => "the scale parameter $of",
	    @common })];

    $funcs{'dbeta'} = $funcs{'pbeta'} = $funcs{'qbeta'} =
	[\&distribution,
	 'beta',
	 ({ 'a' => "the first shape parameter $of",
	    'b' => "the second scale parameter $of",
	    @common })];
    $argoverride{"pbeta:pin"} = "a";
    $argoverride{"pbeta:qin"} = "b";
    $argoverride{"qbeta:p"} = "a";
    $argoverride{"qbeta:q"} = "b";

    $funcs{'dt'} = $funcs{'pt'} = $funcs{'qt'} =
	[\&distribution,
	 'Student t',
	 ({ 'n' => "the number of degrees of freedom $of",
	    @common })];
    $argoverride{"qt:ndf"} = "n";
}

my %type_getter =
    ('gnm_float' => 'value_get_as_float',
     'gboolean' => 'value_get_as_int', # Sorry
     );

my %type_spec =
    ('gnm_float' => 'f',
     'gboolean' => 'f', # ???
     );

my %type_setter =
    ('gnm_float' => 'value_new_float',
     'int' => 'value_new_int',
     'gboolean' => 'value_new_bool',
     );

# -----------------------------------------------------------------------------

my $mathfunch = $0;
$mathfunch =~ s|[^/]+$|../../src/mathfunc.h|;

my $funcdefs = "";
my @funcnames = ();

my $emitted = "";

&emit ("/* This code was generated by $0.  Do not edit. */\n\n" .
       "#include <gnumeric-config.h>\n" .
       "#include <gnumeric.h>\n" .
       "#include <goffice/app/go-plugin.h>\n" .
       "#include <gnm-plugin.h>\n" .
       "#include <func.h>\n\n" .
       "#include <gnm-i18n.h>\n\n" .
       "#include <value.h>\n\n" .
       "#include <mathfunc.h>\n\n" .
       "GNM_PLUGIN_MODULE_HEADER;\n\n");

open (HEADER, "<$mathfunch") or die "$0: Cannot read $mathfunch: $!\n";
while (<HEADER>) {
    chomp;

    if (/^(gnm_float)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(.*\)/) {
	my $restype = $1;
	my $func = $2;
	next unless exists $funcs{$func};
	my ($handler,@args) = @{ $funcs{$func} };

	&$handler ($func, $restype, $_, @args);
	push @funcnames, "r.$func";
    }
}
close (HEADER);

&emit_line ();
&emit ("\n" .
       "GnmFuncDescriptor const stat_functions[] = {\n" .
       $funcdefs .
       "\t{ NULL }\n" .
       "};\n");
&emit_dump ("functions.c");

&create_plugin_xml_in (@funcnames);

# -----------------------------------------------------------------------------

sub distribution {
    my ($func,$restype,$proto,$distname,$argdescs) = @_;

    my $args = $proto;
    $args =~ s/^.*\((.*)\)\s*;$/$1/;

    my @args = ();
    foreach (split (/\s*,\s*/, $args)) {
	my ($type,$name) = split (' ');
	$name = $argoverride{"$func:$name"} || $argoverride{$name} || $name;
	push @args, [$type,$name];
    }

    my $body = "";
    my $typespec = "";
    my $helpargs = "";
    my $helpargsdesc = "";
    my $n = 0;
    foreach (@args) {
	my ($type,$name) = @{ $_ };
	my $def = undef;
	$def = 'TRUE' if $name eq 'lower_tail';
	$def = 'FALSE' if $name eq 'give_log' || $name eq 'log_p';
	$body .= ("\t$type $name = " .
		  (defined ($def) ? "args[$n] ? " : "") .
		  $type_getter{$type} . " (args[$n])" .
		  (defined ($def) ? " : $def" : "") .
		  ";\n");

	if (exists $argdescs->{$name}) {
	    $helpargsdesc .= "* \@$name: " . $argdescs->{$name} . "\n";
	}

	if (defined ($def) && $typespec !~ /\|/) {
	    $helpargs .= "[";
	    $typespec .= "|" ;
	}
	$helpargs .= ($n ? "," : "") . $name;
	$typespec .= $type_spec{$type};
	$n++;
    }
    $body .= ("\n\treturn " . $type_setter{$restype} . " (" .
	      "$func (" .
	      join (", ", map { $_->[1] } @args) .
	      "));\n");
    $helpargs .="]" if $helpargs =~ /\[/;

    my $what = ($func =~ /^d/
		? "probability density function"
		: ($func =~ /^p/
		   ? "cumulative probability density function"
		   : "probability quantile function"));

    my $seealso = "";
    my $f1 = substr ($func, 1);
    my $F1 = uc ($f1);
    $seealso .= ",R.D$F1" if ($func !~ /^d/) && exists $funcs{"d$f1"};
    $seealso .= ",R.P$F1" if $func !~ /^p/ && exists $funcs{"p$f1"};
    $seealso .= ",R.Q$F1" if $func !~ /^q/ && exists $funcs{"q$f1"};
    $seealso =~ s/^,\s*//;

    my $helpbody =
	("\@FUNCTION=" . uc ("r.$func") . "\n" .
	 "\@SYNTAX=" . uc ("r.$func") . "($helpargs)\n" .
	 "\@DESCRIPTION=" .
	 uc ("r.$func") . " function return the $what " .
	 "of the $distname distribution.\n\n" .
	 "$helpargsdesc\n" .
	 "\@EXAMPLES=\n\n" .
	 "\@SEEALSO=$seealso");

    &emit_line ();

    &emit ("\n" .
	   "static GnmFuncHelp const help_r_$func\[\] = {\n" .
	   "\t{ GNM_FUNC_HELP_OLD,\n" .
	   "\tF_(\"" . join ("\\n\"\n\t   \"", map { "$_" } (split ("\n", $helpbody))) . "\")\n" .
	   "\t},\n" .
	   "\t{ GNM_FUNC_HELP_END }\n" .
	   "};\n\n");

    &emit ("static GnmValue *\n" .
	   "gnumeric_r_$func (FunctionEvalInfo *ei, GnmValue **args)\n" .
	   "{\n" .
	   $body .
	   "}\n\n");

    my $arglist = join (",", map { $_->[1] } @args);

    $funcdefs .= ("\t{\n" .
		  "\t\t\"r.$func\",\n" .
		  "\t\t\"$typespec\",\n" .
		  "\t\tN_(\"$arglist\"),\n" .
		  "\t\thelp_r_$func,\n" .
		  "\t\tgnumeric_r_$func, NULL, NULL, NULL, NULL,\n" .
		  "\t\tGNM_FUNC_SIMPLE, GNM_FUNC_IMPL_STATUS_UNIQUE_TO_GNUMERIC, GNM_FUNC_TEST_STATUS_NO_TESTSUITE,\n" .
		  "\t},\n");
}

# -----------------------------------------------------------------------------

sub emit {
    my ($code) = @_;
    $emitted .= $code;
}

sub emit_line {
    &emit ("/* " . ('-' x 73) . " */\n\n");
}

sub emit_dump {
    my ($filename) = @_;

    my $tmpfilename = "$filename.new";
    print STDERR "Creating $filename";
    local (*FIL);
    open (FIL, ">$tmpfilename") or die "Cannot write to $tmpfilename: $!\n";
    print FIL $emitted;
    close (*FIL);

    &update_file ($filename);

    $emitted = "";
}

# -----------------------------------------------------------------------------

sub update_file {
    my ($old) = @_;
    my ($new) = "$old.new";

    if (!-r $old) {
	rename $new, $old or
	    die "$0: Cannot rename $new to $old: $!\n";
	print STDERR " -- done.\n";
    } else {
	system ("cmp '$old' '$new' >/dev/null");
	if ($? == 0) {
	    print STDERR " -- unchanged.\n";
	    unlink $new;
	} else {
	    rename $new, $old or
		die "$0: Cannot rename $new to $old: $!\n";
	    print STDERR " -- done.\n";
	}
    }
}

# -----------------------------------------------------------------------------

sub create_plugin_xml_in {
    my (@funcnames) = @_;

    &emit ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" .
	   "<plugin id=\"Gnumeric_r\">\n" .
	   "\t<information>\n" .
	   "\t\t<_name>Statistical Functions</_name>\n" .
	   "\t\t<_description>Statistical Functions with naming a calling conventions from The R Project</_description>\n" .
	   "\t</information>\n" .
	   "\t<loader type=\"Gnumeric_Builtin:module\">\n" .
	   "\t\t<attribute name=\"module_file\" value=\"rstat\"/>\n" .
	   "\t</loader>\n" .
	   "\t<services>\n" .
	   "\t\t<service type=\"function_group\" id=\"stat\">\n" .
	   "\t\t\t<_category>Statistics</_category>\n" .
	   "\t\t\t<functions>\n");

    foreach my $rfunc (sort @funcnames) {
	&emit ("\t\t\t\t<function name=\"$rfunc\"/>\n");
    }

    &emit ("\t\t\t</functions>\n" .
	   "\t\t</service>\n" .
	   "\t</services>\n" .
	   "</plugin>\n");

    &emit_dump ("plugin.xml.in");
}

# -----------------------------------------------------------------------------
