#!/usr/bin/perl -w 

#  An XML to PO Template file converter
#  (C) 2000 The Free Software Foundation
#
#  Authors: Kenneth Christiansen <kenneth@gnu.org>


use strict;
use Getopt::Long;

my $FILE	= $ARGV[0];
my $HELP_ARG 	= "0";
my $VERSION_ARG = "0";
my $VERSION 	= "0.5";
my %string 	= ();
my $n		= 0;

$| = 1;

GetOptions (
	    "help|h|?"   => \$HELP_ARG,
	    "version|v"  => \$VERSION_ARG,
	    ) or &Error2;

&SplitOnArgument;


#---------------------------------------------------
# Check for options. 
# This section will check for the different options.
#---------------------------------------------------

sub SplitOnArgument {

    if ($VERSION_ARG) {
	&Version;

    } elsif ($HELP_ARG) {
	&Help;   

    } elsif (@ARGV > 0) {
	&Xmlfiles;

    } else {
	&Xmlfiles;

    }  
}    

#-------------------
sub Version{
    print "The XML to POT Converter $VERSION\n";
    print "Written by Kenneth Christiansen, 2000.\n\n";
    print "Copyright (C) 2000 Free Software Foundation, Inc.\n";
    print "This is free software; see the source for copying conditions.  There is NO\n";
    print "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n";
    exit;
}

#-------------------  
sub Help{
    print "Usage: xml2pot [FILENAME] [OPTIONS] ...\n";
    print "Generates a pot file from an xml source.\n\nGraps all strings ";
    print "between <_translatable_node> and it's end tag,\nwhere tag are all allowed ";
    print "xml tags. Read the docs for more info.\n\n"; 
    print "  -V, --version                shows the version\n";
    print "  -H, --help                   shows this help page\n";
    print "\nReport bugs to <kenneth\@gnu.org>.\n";
    exit;
}

#------------------- 
sub Error2{
#   print "ui-extract: invalid option @ARGV\n";
    print "Try `ui-extract.pl --help' for more information.\n";
    exit;
}

sub Xmlfiles {
    print "Generating headerfile for XML translation.";

   if (-s "$FILE.h"){
	unlink "$FILE.h";
   }

    &Convert ($FILE);


    open OUT, ">>$FILE.h";
    &addMessages;
    close OUT;

    print  "\nWrote $FILE.h\n";
}

#-------------------
sub Convert($) {

    #-----------------
    # Reading the file
    #-----------------
    my $input; {
	local (*IN);
	local $/; #slurp mode
	open (IN, "< $_[0]") || die "can't open $_[0]: $!";
	$input = <IN>;
    }
 
    my $check2_input = $input;

    if (!-s "$FILE.h"){
    	open OUT, ">$FILE.h";

	print OUT "/*\n";
        print OUT " * Translatable strings file generated by extract-ui.\n";
        print OUT " * Add this file to your project's POTFILES.in\n";
        print OUT " * DO NOT compile it as part of your application.\n";
        print OUT " */\n\n"; 
			
        }   
       	close OUT;

        while ($input =~ /_[a-zA-Z0-9_]+=\"([^\"]*)\"/sg) {
	   	$string{$1} = [];
        }

	while ($check2_input =~ /<_[a-zA-Z0-9_]+>(..[^_]*)<\/_[a-zA-Z0-9_]+>/sg) {
		$string{$1} = [];
 	}
    }

sub addMessages{

    foreach my $theMessage (sort keys %string) {
	my ($lineNo,$fileName) = @{ $string{$theMessage} };

    if ($theMessage =~ /\n/) {
	print OUT "gchar *s = N_("; 

	$n = 1;
        for (split /\n/, $theMessage) {
	    $_ =~ s/^\s+//mg;
	    if ($n > 1) { print OUT "              ";}
            $n++;
	    print OUT "\"$_\");\n";
	}

	} else {
		
	    print OUT "gchar *s = N_(\"$theMessage\");\n";

	}
	    
    }
}

