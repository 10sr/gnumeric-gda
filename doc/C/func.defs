@CATEGORY=Bitwise Operations
@FUNCTION=BITAND
@SYNTAX=BITAND(a,b)
@DESCRIPTION=BITAND returns the bitwise and of the binary representations of its arguments.
@{a}: non-negative integer
@{b}: non-negative integer

@SEEALSO=BITOR,BITXOR

@CATEGORY=Bitwise Operations
@FUNCTION=BITLSHIFT
@SYNTAX=BITLSHIFT(a,n)
@DESCRIPTION=BITLSHIFT returns the binary representations of @{a} shifted @{n} positions to the left.
@{a}: non-negative integer
@{n}: integer

@NOTE=If @{n} is negative, BITLSHIFT shifts the bits to the right by ABS(@{n}) positions.
@SEEALSO=BITRSHIFT

@CATEGORY=Bitwise Operations
@FUNCTION=BITOR
@SYNTAX=BITOR(a,b)
@DESCRIPTION=BITOR returns the bitwise or of the binary representations of its arguments.
@{a}: non-negative integer
@{b}: non-negative integer

@SEEALSO=BITXOR,BITAND

@CATEGORY=Bitwise Operations
@FUNCTION=BITRSHIFT
@SYNTAX=BITRSHIFT(a,n)
@DESCRIPTION=BITRSHIFT returns the binary representations of @{a} shifted @{n} positions to the right.
@{a}: non-negative integer
@{n}: integer

@NOTE=If @{n} is negative, BITRSHIFT shifts the bits to the left by ABS(@{n}) positions.
@SEEALSO=BITLSHIFT

@CATEGORY=Bitwise Operations
@FUNCTION=BITXOR
@SYNTAX=BITXOR(a,b)
@DESCRIPTION=BITXOR returns the bitwise exclusive or of the binary representations of its arguments.
@{a}: non-negative integer
@{b}: non-negative integer

@SEEALSO=BITOR,BITAND

@CATEGORY=Complex
@FUNCTION=COMPLEX
@SYNTAX=COMPLEX(x,y,i)
@DESCRIPTION=.
@{x}: real part
@{y}: imaginary part
@{i}: the suffix for the complex number, either "i" or "j"; defaults to "i".
@NOTE=If @{i} is neither "i" nor "j", COMPLEX returns #VALUE!

@CATEGORY=Complex
@FUNCTION=IMABS
@SYNTAX=IMABS(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMAGINARY,IMREAL

@CATEGORY=Complex
@FUNCTION=IMAGINARY
@SYNTAX=IMAGINARY(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMREAL

@CATEGORY=Complex
@FUNCTION=IMARCCOS
@SYNTAX=IMARCCOS(z)
@DESCRIPTION=IMARCCOS returns the complex arccosine of the complex number @{z}. The branch cuts are on the real axis, less than -1 and greater than 1.
@{z}: a complex number

@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMARCSIN,IMARCTAN

@CATEGORY=Complex
@FUNCTION=IMARCCOSH
@SYNTAX=IMARCCOSH(z)
@DESCRIPTION=IMARCCOSH returns the complex hyperbolic arccosine of the complex number @{z}. The branch cut is on the real axis, less than 1.
@{z}: a complex number

@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMARCSINH,IMARCTANH

@CATEGORY=Complex
@FUNCTION=IMARCCOT
@SYNTAX=IMARCCOT(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMARCSEC,IMARCCSC

@CATEGORY=Complex
@FUNCTION=IMARCCOTH
@SYNTAX=IMARCCOTH(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMARCSECH,IMARCCSCH

@CATEGORY=Complex
@FUNCTION=IMARCCSC
@SYNTAX=IMARCCSC(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMARCSEC,IMARCCOT

@CATEGORY=Complex
@FUNCTION=IMARCCSCH
@SYNTAX=IMARCCSCH(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMARCSECH,IMARCCOTH

@CATEGORY=Complex
@FUNCTION=IMARCSEC
@SYNTAX=IMARCSEC(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMARCCSC,IMARCCOT

@CATEGORY=Complex
@FUNCTION=IMARCSECH
@SYNTAX=IMARCSECH(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMARCCSCH,IMARCCOTH

@CATEGORY=Complex
@FUNCTION=IMARCSIN
@SYNTAX=IMARCSIN(z)
@DESCRIPTION=IMARCSIN returns the complex arcsine of the complex number @{z}. The branch cuts are on the real axis, less than -1 and greater than 1.
@{z}: a complex number

@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMARCCOS,IMARCTAN

@CATEGORY=Complex
@FUNCTION=IMARCSINH
@SYNTAX=IMARCSINH(z)
@DESCRIPTION=IMARCSINH returns the complex hyperbolic arcsine of the complex number @{z}.  The branch cuts are on the imaginary axis, below -i and above i.
@{z}: a complex number

@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMARCCOSH,IMARCTANH

@CATEGORY=Complex
@FUNCTION=IMARCTAN
@SYNTAX=IMARCTAN(z)
@DESCRIPTION=IMARCTAN returns the complex arctangent of the complex number @{z}. The branch cuts are on the imaginary axis, below -i and above i.
@{z}: a complex number

@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMARCSIN,IMARCCOS

@CATEGORY=Complex
@FUNCTION=IMARCTANH
@SYNTAX=IMARCTANH(z)
@DESCRIPTION=IMARCTANH returns the complex hyperbolic arctangent of the complex number @{z}. The branch cuts are on the real axis, less than -1 and greater than 1.
@{z}: a complex number

@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMARCSINH,IMARCCOSH

@CATEGORY=Complex
@FUNCTION=IMARGUMENT
@SYNTAX=IMARGUMENT(z)
@DESCRIPTION=The argument theta of a complex number is its angle in radians from the real axis.
@{z}: a complex number

@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.

@CATEGORY=Complex
@FUNCTION=IMCONJUGATE
@SYNTAX=IMCONJUGATE(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMAGINARY,IMREAL

@CATEGORY=Complex
@FUNCTION=IMCOS
@SYNTAX=IMCOS(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMSIN,IMTAN

@CATEGORY=Complex
@FUNCTION=IMCOSH
@SYNTAX=IMCOSH(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMSINH,IMTANH

@CATEGORY=Complex
@FUNCTION=IMCOT
@SYNTAX=IMCOT(z)
@DESCRIPTION=cotz = cosz/sinz.
@{z}: a complex number

@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMSEC,IMCSC

@CATEGORY=Complex
@FUNCTION=IMCOTH
@SYNTAX=IMCOTH(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMSECH,IMCSCH

@CATEGORY=Complex
@FUNCTION=IMCSC
@SYNTAX=IMCSC(z)
@DESCRIPTION=cscz = 1/sinz.
@{z}: a complex number

@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMSEC,IMCOT

@CATEGORY=Complex
@FUNCTION=IMCSCH
@SYNTAX=IMCSCH(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMSECH,IMCOTH

@CATEGORY=Complex
@FUNCTION=IMDIV
@SYNTAX=IMDIV(z1,z2)
@DESCRIPTION=.
@{z1}: a complex number
@{z2}: a complex number
@NOTE=If @{z1} or @{z2} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMPRODUCT

@CATEGORY=Complex
@FUNCTION=IMEXP
@SYNTAX=IMEXP(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMLN

@CATEGORY=Complex
@FUNCTION=IMINV
@SYNTAX=IMINV(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.

@CATEGORY=Complex
@FUNCTION=IMLN
@SYNTAX=IMLN(z)
@DESCRIPTION=The result will have an imaginary part between -π and +π.
The natural logarithm is not uniquely defined on complex numbers. You may need to add or subtract an even multiple of π to the imaginary part.
@{z}: a complex number

@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMEXP,IMLOG2,IMLOG10

@CATEGORY=Complex
@FUNCTION=IMLOG10
@SYNTAX=IMLOG10(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMLN,IMLOG2

@CATEGORY=Complex
@FUNCTION=IMLOG2
@SYNTAX=IMLOG2(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMLN,IMLOG10

@CATEGORY=Complex
@FUNCTION=IMNEG
@SYNTAX=IMNEG(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.

@CATEGORY=Complex
@FUNCTION=IMPOWER
@SYNTAX=IMPOWER(z1,z2)
@DESCRIPTION=.
@{z1}: a complex number
@{z2}: a complex number
@NOTE=If @{z1} or @{z2} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMSQRT

@CATEGORY=Complex
@FUNCTION=IMPRODUCT
@SYNTAX=IMPRODUCT(z1,z2)
@DESCRIPTION=.
@{z1}: a complex number
@{z2}: a complex number
@NOTE=If any of @{z1}, @{z2},... is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMDIV

@CATEGORY=Complex
@FUNCTION=IMREAL
@SYNTAX=IMREAL(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMAGINARY

@CATEGORY=Complex
@FUNCTION=IMSEC
@SYNTAX=IMSEC(z)
@DESCRIPTION=secz = 1/cosz.
@{z}: a complex number

@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMCSC,IMCOT

@CATEGORY=Complex
@FUNCTION=IMSECH
@SYNTAX=IMSECH(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMCSCH,IMCOTH

@CATEGORY=Complex
@FUNCTION=IMSIN
@SYNTAX=IMSIN(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMCOS,IMTAN

@CATEGORY=Complex
@FUNCTION=IMSINH
@SYNTAX=IMSINH(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMCOSH,IMTANH

@CATEGORY=Complex
@FUNCTION=IMSQRT
@SYNTAX=IMSQRT(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMPOWER

@CATEGORY=Complex
@FUNCTION=IMSUB
@SYNTAX=IMSUB(z1,z2)
@DESCRIPTION=.
@{z1}: a complex number
@{z2}: a complex number
@NOTE=If @{z1} or @{z2} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMSUM

@CATEGORY=Complex
@FUNCTION=IMSUM
@SYNTAX=IMSUM(z1,z2)
@DESCRIPTION=.
@{z1}: a complex number
@{z2}: a complex number
@NOTE=If any of @{z1}, @{z2},... is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMSUB

@CATEGORY=Complex
@FUNCTION=IMTAN
@SYNTAX=IMTAN(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMSIN,IMCOS

@CATEGORY=Complex
@FUNCTION=IMTANH
@SYNTAX=IMTANH(z)
@DESCRIPTION=.
@{z}: a complex number
@NOTE=If @{z} is not a valid complex number, #VALUE! is returned.
@SEEALSO=IMSINH,IMCOSH

@CATEGORY=Database
@FUNCTION=DAVERAGE
@SYNTAX=DAVERAGE(database,field,criteria)
@DESCRIPTION=@{database} is a range in which rows of related information are records and columns of data are fields. The first row of a database contains labels for each column.
@{database}: a range in which rows of related information are records and columns of data are fields
@{field}: a string or integer specifying which field is to be used
@{criteria}: a range containing conditions

@DESCRIPTION=@{field} is a string or integer specifying which field is to be used. If @{field} is an integer n then the nth column will be used. If @{field} is a string, then the column with the matching label will be used.
@DESCRIPTION=@{criteria} is a range containing conditions. The first row of a @{criteria} should contain labels. Each label specifies to which field the conditions given in that column apply. Each cell below the label specifies a condition such as ">3" or "<9". An equality condition can be given by simply specifying a value, e. g. "3" or "Jody". For a record to be considered it must satisfy all conditions in at least one of the rows of @{criteria}.
@SEEALSO=DCOUNT

@CATEGORY=Database
@FUNCTION=DCOUNT
@SYNTAX=DCOUNT(database,field,criteria)
@DESCRIPTION=@{database} is a range in which rows of related information are records and columns of data are fields. The first row of a database contains labels for each column.
@{database}: a range in which rows of related information are records and columns of data are fields
@{field}: a string or integer specifying which field is to be used
@{criteria}: a range containing conditions

@DESCRIPTION=@{field} is a string or integer specifying which field is to be used. If @{field} is an integer n then the nth column will be used. If @{field} is a string, then the column with the matching label will be used.
@DESCRIPTION=@{criteria} is a range containing conditions. The first row of a @{criteria} should contain labels. Each label specifies to which field the conditions given in that column apply. Each cell below the label specifies a condition such as ">3" or "<9". An equality condition can be given by simply specifying a value, e. g. "3" or "Jody". For a record to be considered it must satisfy all conditions in at least one of the rows of @{criteria}.
@SEEALSO=DAVERAGE,DCOUNTA

@CATEGORY=Database
@FUNCTION=DCOUNTA
@SYNTAX=DCOUNTA(database,field,criteria)
@DESCRIPTION=@{database} is a range in which rows of related information are records and columns of data are fields. The first row of a database contains labels for each column.
@{database}: a range in which rows of related information are records and columns of data are fields
@{field}: a string or integer specifying which field is to be used
@{criteria}: a range containing conditions

@DESCRIPTION=@{field} is a string or integer specifying which field is to be used. If @{field} is an integer n then the nth column will be used. If @{field} is a string, then the column with the matching label will be used.
@DESCRIPTION=@{criteria} is a range containing conditions. The first row of a @{criteria} should contain labels. Each label specifies to which field the conditions given in that column apply. Each cell below the label specifies a condition such as ">3" or "<9". An equality condition can be given by simply specifying a value, e. g. "3" or "Jody". For a record to be considered it must satisfy all conditions in at least one of the rows of @{criteria}.
@SEEALSO=DCOUNT

@CATEGORY=Database
@FUNCTION=DGET
@SYNTAX=DGET(database,field,criteria)
@DESCRIPTION=@{database} is a range in which rows of related information are records and columns of data are fields. The first row of a database contains labels for each column.
@{database}: a range in which rows of related information are records and columns of data are fields
@{field}: a string or integer specifying which field is to be used
@{criteria}: a range containing conditions

@DESCRIPTION=@{field} is a string or integer specifying which field is to be used. If @{field} is an integer n then the nth column will be used. If @{field} is a string, then the column with the matching label will be used.
@DESCRIPTION=@{criteria} is a range containing conditions. The first row of a @{criteria} should contain labels. Each label specifies to which field the conditions given in that column apply. Each cell below the label specifies a condition such as ">3" or "<9". An equality condition can be given by simply specifying a value, e. g. "3" or "Jody". For a record to be considered it must satisfy all conditions in at least one of the rows of @{criteria}.
@NOTE=If none of the records match the conditions, DGET returns #VALUE!
@NOTE=If more than one record match the conditions, DGET returns #NUM!
@SEEALSO=DCOUNT

@CATEGORY=Database
@FUNCTION=DMAX
@SYNTAX=DMAX(database,field,criteria)
@DESCRIPTION=@{database} is a range in which rows of related information are records and columns of data are fields. The first row of a database contains labels for each column.
@{database}: a range in which rows of related information are records and columns of data are fields
@{field}: a string or integer specifying which field is to be used
@{criteria}: a range containing conditions

@DESCRIPTION=@{field} is a string or integer specifying which field is to be used. If @{field} is an integer n then the nth column will be used. If @{field} is a string, then the column with the matching label will be used.
@DESCRIPTION=@{criteria} is a range containing conditions. The first row of a @{criteria} should contain labels. Each label specifies to which field the conditions given in that column apply. Each cell below the label specifies a condition such as ">3" or "<9". An equality condition can be given by simply specifying a value, e. g. "3" or "Jody". For a record to be considered it must satisfy all conditions in at least one of the rows of @{criteria}.
@SEEALSO=DMIN

@CATEGORY=Database
@FUNCTION=DMIN
@SYNTAX=DMIN(database,field,criteria)
@DESCRIPTION=@{database} is a range in which rows of related information are records and columns of data are fields. The first row of a database contains labels for each column.
@{database}: a range in which rows of related information are records and columns of data are fields
@{field}: a string or integer specifying which field is to be used
@{criteria}: a range containing conditions

@DESCRIPTION=@{field} is a string or integer specifying which field is to be used. If @{field} is an integer n then the nth column will be used. If @{field} is a string, then the column with the matching label will be used.
@DESCRIPTION=@{criteria} is a range containing conditions. The first row of a @{criteria} should contain labels. Each label specifies to which field the conditions given in that column apply. Each cell below the label specifies a condition such as ">3" or "<9". An equality condition can be given by simply specifying a value, e. g. "3" or "Jody". For a record to be considered it must satisfy all conditions in at least one of the rows of @{criteria}.
@SEEALSO=DCOUNT

@CATEGORY=Database
@FUNCTION=DPRODUCT
@SYNTAX=DPRODUCT(database,field,criteria)
@DESCRIPTION=@{database} is a range in which rows of related information are records and columns of data are fields. The first row of a database contains labels for each column.
@{database}: a range in which rows of related information are records and columns of data are fields
@{field}: a string or integer specifying which field is to be used
@{criteria}: a range containing conditions

@DESCRIPTION=@{field} is a string or integer specifying which field is to be used. If @{field} is an integer n then the nth column will be used. If @{field} is a string, then the column with the matching label will be used.
@DESCRIPTION=@{criteria} is a range containing conditions. The first row of a @{criteria} should contain labels. Each label specifies to which field the conditions given in that column apply. Each cell below the label specifies a condition such as ">3" or "<9". An equality condition can be given by simply specifying a value, e. g. "3" or "Jody". For a record to be considered it must satisfy all conditions in at least one of the rows of @{criteria}.
@SEEALSO=DSUM

@CATEGORY=Database
@FUNCTION=DSTDEV
@SYNTAX=DSTDEV(database,field,criteria)
@DESCRIPTION=@{database} is a range in which rows of related information are records and columns of data are fields. The first row of a database contains labels for each column.
@{database}: a range in which rows of related information are records and columns of data are fields
@{field}: a string or integer specifying which field is to be used
@{criteria}: a range containing conditions

@DESCRIPTION=@{field} is a string or integer specifying which field is to be used. If @{field} is an integer n then the nth column will be used. If @{field} is a string, then the column with the matching label will be used.
@DESCRIPTION=@{criteria} is a range containing conditions. The first row of a @{criteria} should contain labels. Each label specifies to which field the conditions given in that column apply. Each cell below the label specifies a condition such as ">3" or "<9". An equality condition can be given by simply specifying a value, e. g. "3" or "Jody". For a record to be considered it must satisfy all conditions in at least one of the rows of @{criteria}.
@SEEALSO=DSTDEVP

@CATEGORY=Database
@FUNCTION=DSTDEVP
@SYNTAX=DSTDEVP(database,field,criteria)
@DESCRIPTION=@{database} is a range in which rows of related information are records and columns of data are fields. The first row of a database contains labels for each column.
@{database}: a range in which rows of related information are records and columns of data are fields
@{field}: a string or integer specifying which field is to be used
@{criteria}: a range containing conditions

@DESCRIPTION=@{field} is a string or integer specifying which field is to be used. If @{field} is an integer n then the nth column will be used. If @{field} is a string, then the column with the matching label will be used.
@DESCRIPTION=@{criteria} is a range containing conditions. The first row of a @{criteria} should contain labels. Each label specifies to which field the conditions given in that column apply. Each cell below the label specifies a condition such as ">3" or "<9". An equality condition can be given by simply specifying a value, e. g. "3" or "Jody". For a record to be considered it must satisfy all conditions in at least one of the rows of @{criteria}.
@SEEALSO=DSTDEV

@CATEGORY=Database
@FUNCTION=DSUM
@SYNTAX=DSUM(database,field,criteria)
@DESCRIPTION=@{database} is a range in which rows of related information are records and columns of data are fields. The first row of a database contains labels for each column.
@{database}: a range in which rows of related information are records and columns of data are fields
@{field}: a string or integer specifying which field is to be used
@{criteria}: a range containing conditions

@DESCRIPTION=@{field} is a string or integer specifying which field is to be used. If @{field} is an integer n then the nth column will be used. If @{field} is a string, then the column with the matching label will be used.
@DESCRIPTION=@{criteria} is a range containing conditions. The first row of a @{criteria} should contain labels. Each label specifies to which field the conditions given in that column apply. Each cell below the label specifies a condition such as ">3" or "<9". An equality condition can be given by simply specifying a value, e. g. "3" or "Jody". For a record to be considered it must satisfy all conditions in at least one of the rows of @{criteria}.
@SEEALSO=DPRODUCT

@CATEGORY=Database
@FUNCTION=DVAR
@SYNTAX=DVAR(database,field,criteria)
@DESCRIPTION=@{database} is a range in which rows of related information are records and columns of data are fields. The first row of a database contains labels for each column.
@{database}: a range in which rows of related information are records and columns of data are fields
@{field}: a string or integer specifying which field is to be used
@{criteria}: a range containing conditions

@DESCRIPTION=@{field} is a string or integer specifying which field is to be used. If @{field} is an integer n then the nth column will be used. If @{field} is a string, then the column with the matching label will be used.
@DESCRIPTION=@{criteria} is a range containing conditions. The first row of a @{criteria} should contain labels. Each label specifies to which field the conditions given in that column apply. Each cell below the label specifies a condition such as ">3" or "<9". An equality condition can be given by simply specifying a value, e. g. "3" or "Jody". For a record to be considered it must satisfy all conditions in at least one of the rows of @{criteria}.
@SEEALSO=DVARP

@CATEGORY=Database
@FUNCTION=DVARP
@SYNTAX=DVARP(database,field,criteria)
@DESCRIPTION=@{database} is a range in which rows of related information are records and columns of data are fields. The first row of a database contains labels for each column.
@{database}: a range in which rows of related information are records and columns of data are fields
@{field}: a string or integer specifying which field is to be used
@{criteria}: a range containing conditions

@DESCRIPTION=@{field} is a string or integer specifying which field is to be used. If @{field} is an integer n then the nth column will be used. If @{field} is a string, then the column with the matching label will be used.
@DESCRIPTION=@{criteria} is a range containing conditions. The first row of a @{criteria} should contain labels. Each label specifies to which field the conditions given in that column apply. Each cell below the label specifies a condition such as ">3" or "<9". An equality condition can be given by simply specifying a value, e. g. "3" or "Jody". For a record to be considered it must satisfy all conditions in at least one of the rows of @{criteria}.
@SEEALSO=DVAR

@CATEGORY=Database
@FUNCTION=GETPIVOTDATA
@SYNTAX=GETPIVOTDATA(pivot_table,field_name)
@DESCRIPTION=.
@{pivot_table}: cell range containing the pivot table
@{field_name}: name of the field for which the summary data is requested
@NOTE=If the summary data is unavailable, GETPIVOTDATA returns #REF!

@CATEGORY=Date/Time
@FUNCTION=ASCENSIONTHURSDAY
@SYNTAX=ASCENSIONTHURSDAY(year)
@DESCRIPTION=.
@{year}: year between 1582 and 9956, defaults to the year of the next Ascension Thursday
@NOTE=Two digit years are adjusted as elsewhere in Gnumeric. Dates before 1904 may also be prohibited.
@SEEALSO=EASTERSUNDAY

@CATEGORY=Date/Time
@FUNCTION=ASHWEDNESDAY
@SYNTAX=ASHWEDNESDAY(year)
@DESCRIPTION=.
@{year}: year between 1582 and 9956, defaults to the year of the next Ash Wednesday
@NOTE=Two digit years are adjusted as elsewhere in Gnumeric. Dates before 1904 may also be prohibited.
@SEEALSO=EASTERSUNDAY

@CATEGORY=Date/Time
@FUNCTION=DATE
@SYNTAX=DATE(year,month,day)
@DESCRIPTION=The DATE function creates date serial values.  1-Jan-1900 is serial value 1, 2-Jan-1900 is serial value 2, and so on.  For compatibility reasons, a serial value is reserved for the non-existing date 29-Feb-1900.
@{year}: year of date
@{month}: month of year
@{day}: day of month

@NOTE=If @{month} or @{day} is less than 1 or too big, then the year and/or month will be adjusted.
@NOTE=For spreadsheets created with the Mac version of Excel, serial 1 is 1-Jan-1904.
@SEEALSO=TODAY,YEAR,MONTH,DAY

@CATEGORY=Date/Time
@FUNCTION=DATE2UNIX
@SYNTAX=DATE2UNIX(d)
@DESCRIPTION=The DATE2UNIX function translates a date serial values into a Unix timestamp.
@{d}: date serial value

@SEEALSO=UNIX2DATE,DATE

@CATEGORY=Date/Time
@FUNCTION=DATEDIF
@SYNTAX=DATEDIF(start_date,end_date,interval)
@DESCRIPTION=DATEDIF returns the distance from @{start_date} to @{end_date} according to the unit specified by @{interval}.
@{start_date}: starting date serial value
@{end_date}: ending date serial value
@{interval}: counting unit

@NOTE=If @{interval} is "y", "m", or "d" then the distance is measured in complete years, months, or days respectively.
@NOTE=If @{interval} is "ym" or "yd" then the distance is measured in complete months or days, respectively, but excluding any difference in years.
@NOTE=If @{interval} is "md" then the distance is measured in complete days but excluding any difference in months.
@SEEALSO=DAYS360

@CATEGORY=Date/Time
@FUNCTION=DATEVALUE
@SYNTAX=DATEVALUE(serial)
@DESCRIPTION=DATEVALUE returns the date serial value part of a date and time serial value.
@{serial}: date and time serial value

@SEEALSO=TIMEVALUE,DATE

@CATEGORY=Date/Time
@FUNCTION=DAY
@SYNTAX=DAY(date)
@DESCRIPTION=The DAY function returns the day-of-month part of @{date}.
@{date}: date serial value

@SEEALSO=DATE,YEAR,MONTH

@CATEGORY=Date/Time
@FUNCTION=DAYS
@SYNTAX=DAYS(start_date,end_date)
@DESCRIPTION=DAYS returns the positive or negative number of days from @{start_date} to @{end_date}.
@{start_date}: starting date serial value
@{end_date}: ending date serial value

@SEEALSO=DATEDIF

@CATEGORY=Date/Time
@FUNCTION=DAYS360
@SYNTAX=DAYS360(start_date,end_date,method)
@DESCRIPTION=DAYS360 returns the number of days from @{start_date} to @{end_date}.
@{start_date}: starting date serial value
@{end_date}: ending date serial value
@{method}: counting method

@NOTE=If @{method} is 0, the default, the MS Excel (tm) US method will be used. This is a somewhat complicated industry standard method where the last day of February is considered to be the 30th day of the month, but only for @{start_date}.
@NOTE=If @{method} is 1, the European method will be used.  In this case, if the day of the month is 31 it will be considered as 30
@NOTE=If @{method} is 2, a saner version of the US method is used in which both dates get the same February treatment.
@SEEALSO=DATEDIF

@CATEGORY=Date/Time
@FUNCTION=EASTERSUNDAY
@SYNTAX=EASTERSUNDAY(year)
@DESCRIPTION=.
@{year}: year between 1582 and 9956, defaults to the year of the next Easter Sunday
@NOTE=Two digit years are adjusted as elsewhere in Gnumeric. Dates before 1904 may also be prohibited.
@SEEALSO=ASHWEDNESDAY

@CATEGORY=Date/Time
@FUNCTION=EDATE
@SYNTAX=EDATE(date,months)
@DESCRIPTION=EDATE returns @{date} moved forward or backward the number of months specified by @{months}.
@{date}: date serial value
@{months}: signed number of months

@SEEALSO=DATE

@CATEGORY=Date/Time
@FUNCTION=EOMONTH
@SYNTAX=EOMONTH(date,months)
@DESCRIPTION=EOMONTH returns the date serial value of the end of the month specified by @{date} adjusted forward or backward the number of months specified by @{months}.
@{date}: date serial value
@{months}: signed number of months

@SEEALSO=EDATE

@CATEGORY=Date/Time
@FUNCTION=GOODFRIDAY
@SYNTAX=GOODFRIDAY(year)
@DESCRIPTION=.
@{year}: year between 1582 and 9956, defaults to the year of the next Good Friday
@NOTE=Two digit years are adjusted as elsewhere in Gnumeric. Dates before 1904 may also be prohibited.
@SEEALSO=EASTERSUNDAY

@CATEGORY=Date/Time
@FUNCTION=HDATE
@SEEALSO=HDATE_HEB,DATE

@CATEGORY=Date/Time
@FUNCTION=HDATE_DAY
@SEEALSO=HDATE_JULIAN

@CATEGORY=Date/Time
@FUNCTION=HDATE_HEB
@SEEALSO=HDATE,DATE

@CATEGORY=Date/Time
@FUNCTION=HDATE_JULIAN
@SEEALSO=HDATE

@CATEGORY=Date/Time
@FUNCTION=HDATE_MONTH
@SEEALSO=HDATE_JULIAN

@CATEGORY=Date/Time
@FUNCTION=HDATE_YEAR
@SEEALSO=HDATE_JULIAN

@CATEGORY=Date/Time
@FUNCTION=HOUR
@SYNTAX=HOUR(time)
@DESCRIPTION=The HOUR function computes the hour part of the fractional day given by @{time}.
@{time}: time of day as fractional day.

@SEEALSO=TIME,MINUTE,SECOND

@CATEGORY=Date/Time
@FUNCTION=ISOWEEKNUM
@SYNTAX=ISOWEEKNUM(date)
@DESCRIPTION=ISOWEEKNUM calculates the week number according to the ISE 8601 standard.  Weeks start on Mondays and week 1 contains the first Thursday of the year.
@{date}: date serial value

@NOTE=January 1 of a year is sometimes in week 52 or 53 of the previous year.  Similarly, December 31 is sometimes in week 1 of the following year.
@SEEALSO=ISOYEAR,WEEKNUM

@CATEGORY=Date/Time
@FUNCTION=ISOYEAR
@SYNTAX=ISOYEAR(date)
@DESCRIPTION=ISOYEAR calculates the year to go with week number according to the ISE 8601 standard.
@{date}: date serial value

@NOTE=January 1 of a year is sometimes in week 52 or 53 of the previous year.  Similarly, December 31 is sometimes in week 1 of the following year.
@SEEALSO=ISOWEEKNUM,YEAR

@CATEGORY=Date/Time
@FUNCTION=MINUTE
@SYNTAX=MINUTE(time)
@DESCRIPTION=The MINUTE function computes the minute part of the fractional day given by @{time}.
@{time}: time of day as fractional day.

@SEEALSO=TIME,HOUR,SECOND

@CATEGORY=Date/Time
@FUNCTION=MONTH
@SYNTAX=MONTH(date)
@DESCRIPTION=The MONTH function returns the month part of @{date}.
@{date}: date serial value

@SEEALSO=DATE,YEAR,DAY

@CATEGORY=Date/Time
@FUNCTION=NETWORKDAYS
@SYNTAX=NETWORKDAYS(start_date,end_date,holidays)
@DESCRIPTION=NETWORKDAYS calculates the number of days from @{start_date} to @{end_date} skipping weekends and @{holidays} in the process.
@{start_date}: starting date serial value
@{end_date}: ending date serial value
@{holidays}: array of holidays

@SEEALSO=WORKDAY

@CATEGORY=Date/Time
@FUNCTION=NOW
@SYNTAX=NOW()
@DESCRIPTION=The NOW function returns the date and time serial value of the moment it is computed.  Recomputing later will produce a different value.

@SEEALSO=DATE

@CATEGORY=Date/Time
@FUNCTION=PENTECOSTSUNDAY
@SYNTAX=PENTECOSTSUNDAY(year)
@DESCRIPTION=.
@{year}: year between 1582 and 9956, defaults to the year of the next Pentecost Sunday
@NOTE=Two digit years are adjusted as elsewhere in Gnumeric. Dates before 1904 may also be prohibited.
@SEEALSO=EASTERSUNDAY

@CATEGORY=Date/Time
@FUNCTION=SECOND
@SYNTAX=SECOND(time)
@DESCRIPTION=The SECOND function computes the seconds part of the fractional day given by @{time}.
@{time}: time of day as fractional day.

@SEEALSO=TIME,HOUR,MINUTE

@CATEGORY=Date/Time
@FUNCTION=TIME
@SYNTAX=TIME(hour,minute,second)
@DESCRIPTION=The TIME function computes the fractional day between midnight at the time given by @{hour}, @{minute}, and @{second}.
@{hour}: hour of the day
@{minute}: minute within the hour
@{second}: second within the minute

@SEEALSO=HOUR,MINUTE,SECOND

@CATEGORY=Date/Time
@FUNCTION=TIMEVALUE
@SYNTAX=TIMEVALUE(serial)
@DESCRIPTION=TIMEVALUE returns the time-of-day part of a date and time serial value.
@{serial}: date and time serial value

@SEEALSO=DATEVALUE,TIME

@CATEGORY=Date/Time
@FUNCTION=TODAY
@SYNTAX=TODAY()
@DESCRIPTION=The TODAY function returns the date serial value of the day it is computed.  Recomputing on a later date will produce a different value.

@SEEALSO=DATE

@CATEGORY=Date/Time
@FUNCTION=UNIX2DATE
@SYNTAX=UNIX2DATE(t)
@DESCRIPTION=The UNIT2DATE function translates Unix timestamps into date serial values.  Unix timestamps are number of seconds since Midnight 1-Jan-1900.
@{t}: Unix time stamp

@SEEALSO=DATE2UNIX,DATE

@CATEGORY=Date/Time
@FUNCTION=WEEKDAY
@SYNTAX=WEEKDAY(date,method)
@DESCRIPTION=The WEEKDAY function returns the day-of-week of @{date}.  The value of @{method} determines how days are numbered.
@{date}: date serial value
@{method}: numbering system

@NOTE=If @{method} is 1, then Sunday is 1, Monday is 2, etc.
@NOTE=If @{method} is 2, then Monday is 1, Sunday is 2, etc.
@NOTE=If @{method} is 3, then Monday is 0, Sunday is 1, etc.
@SEEALSO=DATE,ISOWEEKNUM

@CATEGORY=Date/Time
@FUNCTION=WEEKNUM
@SYNTAX=WEEKNUM(date,method)
@DESCRIPTION=WEEKNUM calculates the week number according to @{method} which defaults to 1.
@{date}: date serial value
@{method}: numbering system

@NOTE=If @{method} is 1, then weeks start on Sundays and days before first Sunday are in week 0.
@NOTE=If @{method} is 2, then weeks start on Mondays and days before first Monday are in week 0.
@NOTE=If @{method} is 150, then the ISO 8601 numbering is used.
@SEEALSO=ISOWEEKNUM

@CATEGORY=Date/Time
@FUNCTION=WORKDAY
@SYNTAX=WORKDAY(date,days,holidays)
@DESCRIPTION=WORKDAY adjusts @{date} by @{days} skipping over weekends and @{holidays} in the process.
@{date}: date serial value
@{days}: number of days to add
@{holidays}: array of holidays

@NOTE=@{days} may be negative.
@SEEALSO=NETWORKDAYS

@CATEGORY=Date/Time
@FUNCTION=YEAR
@SYNTAX=YEAR(date)
@DESCRIPTION=The YEAR function returns the year part of @{date}.
@{date}: date serial value

@SEEALSO=DATE,MONTH,DAY

@CATEGORY=Date/Time
@FUNCTION=YEARFRAC
@SYNTAX=YEARFRAC(start_date,end_date,basis)
@DESCRIPTION=YEARFRAC calculates the number of days from @{start_date} to @{end_date} according to the calendar specified by @{basis}, which defaults to 0, and expresses the result as a fractional number of years.
@{start_date}: starting date serial value
@{end_date}: ending date serial value
@{basis}: calendar basis

@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=DATE

@CATEGORY=Engineering
@FUNCTION=BASE
@SYNTAX=BASE(n,b,length)
@DESCRIPTION=BASE converts @{n} to its string representation in base @{b}. Leading zeroes will be added to reach the minimum length given by @{length}.
@{n}: integer
@{b}: base (2 ≤ @{b} ≤ 36)
@{length}: minimum length of the resulting string

@SEEALSO=DECIMAL

@CATEGORY=Engineering
@FUNCTION=BESSELI
@SYNTAX=BESSELI(X,α)
@DESCRIPTION=.
@{X}: number
@{α}: order (any number)
@NOTE=If @{x} or @{α} are not numeric, #VALUE! is returned. If @{α} < 0, #NUM! is returned.
@SEEALSO=BESSELJ,BESSELK,BESSELY

@CATEGORY=Engineering
@FUNCTION=BESSELJ
@SYNTAX=BESSELJ(X,α)
@DESCRIPTION=.
@{X}: number
@{α}: order (any non-negative integer)
@NOTE=If @{x} or @{α} are not numeric, #VALUE! is returned. If @{α} < 0, #NUM! is returned. If @{α} is not an integer, it is truncated.
@SEEALSO=BESSELI,BESSELK,BESSELY

@CATEGORY=Engineering
@FUNCTION=BESSELK
@SYNTAX=BESSELK(X,α)
@DESCRIPTION=.
@{X}: number
@{α}: order (any number)
@NOTE=If @{x} or @{α} are not numeric, #VALUE! is returned. If @{α} < 0, #NUM! is returned.
@SEEALSO=BESSELI,BESSELJ,BESSELY

@CATEGORY=Engineering
@FUNCTION=BESSELY
@SYNTAX=BESSELY(X,α)
@DESCRIPTION=.
@{X}: number
@{α}: order (any non-negative integer)
@NOTE=If @{x} or @{α} are not numeric, #VALUE! is returned. If @{α} < 0, #NUM! is returned. If @{α} is not an integer, it is truncated.
@SEEALSO=BESSELI,BESSELJ,BESSELK

@CATEGORY=Engineering
@FUNCTION=BIN2DEC
@SEEALSO=DEC2BIN,BIN2OCT,BIN2HEX

@CATEGORY=Engineering
@FUNCTION=BIN2HEX
@SYNTAX=BIN2HEX(x,places)
@DESCRIPTION=If @{places} is given, BIN2HEX pads the result with zeros to achieve exactly @{places} digits. If this is not possible, BIN2HEX returns #NUM!
@{x}: a binary number, either as a string or as a number involving only the digits 0 and 1
@{places}: number of digits

@SEEALSO=HEX2BIN,BIN2OCT,BIN2DEC

@CATEGORY=Engineering
@FUNCTION=BIN2OCT
@SYNTAX=BIN2OCT(x,places)
@DESCRIPTION=If @{places} is given, BIN2OCT pads the result with zeros to achieve exactly @{places} digits. If this is not possible, BIN2OCT returns #NUM!
@{x}: a binary number, either as a string or as a number involving only the digits 0 and 1
@{places}: number of digits

@SEEALSO=OCT2BIN,BIN2DEC,BIN2HEX

@CATEGORY=Engineering
@FUNCTION=CONVERT
@SYNTAX=CONVERT(x,from,to)
@DESCRIPTION=CONVERT returns a conversion from one measurement system to another. @{x} is a value in @{from} units that is to be converted into @{to} units.
@{x}: number
@{from}: unit (string)
@{to}: unit (string)

@NOTE=If @{from} and @{to} are different types, CONVERT returns #N/A!
@DESCRIPTION=@{from} and @{to} can be any of the following:

Weight and mass:
	'g'  			Gram
	'sg' 			Slug
	'lbm'		Pound
	'u'  			U (atomic mass)
	'ozm'		Ounce

Distance:
	'm'   		Meter
	'mi'  		Statute mile
	'Nmi' 		Nautical mile
	'in'  			Inch
	'ft'  			Foot
	'yd'  		Yard
	'ang' 		Angstrom
	'Pica'		Pica

Time:
	'yr'  			Year
	'day' 		Day
	'hr'  			Hour
	'mn'  		Minute
	'sec' 		Second

Pressure:
	'Pa'  		Pascal
	'atm' 		Atmosphere
	'mmHg'		mm of Mercury

Force:
	'N'   			Newton
	'dyn' 		Dyne
	'lbf' 			Pound force

Energy:
	'J'    			Joule
	'e'    		Erg
	'c'    		Thermodynamic calorie
	'cal'  		IT calorie
	'eV'   		Electron volt
	'HPh'  		Horsepower-hour
	'Wh'   		Watt-hour
	'flb'  		Foot-pound
	'BTU'  		BTU

Power:
	'HP'   		Horsepower
	'W'    		Watt

Magnetism:
	'T'    		Tesla
	'ga'   		Gauss

Temperature:
	'C'    		Degree Celsius
	'F'    		Degree Fahrenheit
	'K'    		Degree Kelvin

Liquid measure:
	'tsp'  		Teaspoon
	'tbs'  		Tablespoon
	'oz'   		Fluid ounce
	'cup'  		Cup
	'pt'   		Pint
	'qt'   		Quart
	'gal'  		Gallon
	'l'    			Liter

For metric units any of the following prefixes can be used:
	'Y'  	yotta 		1E+24
	'Z'  	zetta 		1E+21
	'E'  	exa   		1E+18
	'P'  	peta  		1E+15
	'T'  	tera  		1E+12
	'G'  	giga  		1E+09
	'M'  	mega  		1E+06
	'k'  	kilo  		1E+03
	'h'  	hecto 		1E+02
	'e'  	deca (deka)	1E+01
	'd'  	deci  		1E-01
	'c'  	centi 		1E-02
	'm'  	milli 		1E-03
	'u'  	micro 		1E-06
	'n'  	nano  		1E-09
	'p'  	pico  		1E-12
	'f'  	femto 		1E-15
	'a'  	atto  		1E-18
	'z'  	zepto 		1E-21
	'y'  	yocto 		1E-24

@CATEGORY=Engineering
@FUNCTION=DEC2BIN
@SYNTAX=DEC2BIN(x,places)
@DESCRIPTION=If @{places} is given, DEC2BIN pads the result with zeros to achieve exactly @{places} digits. If this is not possible, DEC2BIN returns #NUM!
@{x}: integer
@{places}: number of digits

@SEEALSO=BIN2DEC,DEC2OCT,DEC2HEX

@CATEGORY=Engineering
@FUNCTION=DEC2HEX
@SYNTAX=DEC2HEX(x,places)
@DESCRIPTION=If @{places} is given, DEC2HEX pads the result with zeros to achieve exactly @{places} digits. If this is not possible, DEC2HEX returns #NUM!
@{x}: integer
@{places}: number of digits

@SEEALSO=HEX2DEC,DEC2BIN,DEC2OCT

@CATEGORY=Engineering
@FUNCTION=DEC2OCT
@SYNTAX=DEC2OCT(x,places)
@DESCRIPTION=If @{places} is given, DEC2OCT pads the result with zeros to achieve exactly @{places} digits. If this is not possible, DEC2OCT returns #NUM!
@{x}: integer
@{places}: number of digits

@SEEALSO=OCT2DEC,DEC2BIN,DEC2HEX

@CATEGORY=Engineering
@FUNCTION=DECIMAL
@SEEALSO=BASE

@CATEGORY=Engineering
@FUNCTION=DELTA
@SYNTAX=DELTA(x0,x1)
@DESCRIPTION=DELTA  returns 1 if  @{x1} = @{x0} and 0 otherwise.
@{x0}: number
@{x1}: number, defaults to 0

@NOTE=If either argument is non-numeric, #VALUE! is returned.
@SEEALSO=EXACT,GESTEP

@CATEGORY=Engineering
@FUNCTION=ERF
@SYNTAX=ERF(lower,upper)
@DESCRIPTION=ERF returns 2/sqrt(π)* integral from @{lower} to @{upper} of exp(-t*t) dt
@{lower}: lower limit of the integral, defaults to 0
@{upper}: upper limit of the integral

@SEEALSO=ERFC

@CATEGORY=Engineering
@FUNCTION=ERFC
@SYNTAX=ERFC(x)
@DESCRIPTION=ERFC returns 2/sqrt(π)* integral from @{x} to ∞ of exp(-t*t) dt
@{x}: number

@SEEALSO=ERF

@CATEGORY=Engineering
@FUNCTION=GESTEP
@SYNTAX=GESTEP(x0,x1)
@DESCRIPTION=GESTEP returns 1 if  @{x1} ≤ @{x0} and 0 otherwise.
@{x0}: number
@{x1}: number, defaults to 0

@NOTE=If either argument is non-numeric, #VALUE! is returned.
@SEEALSO=DELTA

@CATEGORY=Engineering
@FUNCTION=HEX2BIN
@SYNTAX=HEX2BIN(x,places)
@DESCRIPTION=If @{places} is given, HEX2BIN pads the result with zeros to achieve exactly @{places} digits. If this is not possible, HEX2BIN returns #NUM!
@{x}: a hexadecimal number, either as a string or as a number if no A to F are needed
@{places}: number of digits

@SEEALSO=BIN2HEX,HEX2OCT,HEX2DEC

@CATEGORY=Engineering
@FUNCTION=HEX2DEC
@SEEALSO=DEC2HEX,HEX2BIN,HEX2OCT

@CATEGORY=Engineering
@FUNCTION=HEX2OCT
@SYNTAX=HEX2OCT(x,places)
@DESCRIPTION=If @{places} is given, HEX2OCT pads the result with zeros to achieve exactly @{places} digits. If this is not possible, HEX2OCT returns #NUM!
@{x}: a hexadecimal number, either as a string or as a number if no A to F are needed
@{places}: number of digits

@SEEALSO=OCT2HEX,HEX2BIN,HEX2DEC

@CATEGORY=Engineering
@FUNCTION=INVSUMINV
@SYNTAX=INVSUMINV(x0,x1)
@DESCRIPTION=.
@{x0}: non-negative number
@{x1}: non-negative number
@NOTE=If any of the arguments is negative, #VALUE! is returned.
If any argument is zero, the result is zero.
@DESCRIPTION=INVSUMINV sum calculates the reciprocal (the inverse) of the sum of reciprocals (inverses) of all its arguments.
@SEEALSO=HARMEAN

@CATEGORY=Engineering
@FUNCTION=OCT2BIN
@SYNTAX=OCT2BIN(x,places)
@DESCRIPTION=If @{places} is given, OCT2BIN pads the result with zeros to achieve exactly @{places} digits. If this is not possible, OCT2BIN returns #NUM!
@{x}: a octal number, either as a string or as a number
@{places}: number of digits

@SEEALSO=BIN2OCT,OCT2DEC,OCT2HEX

@CATEGORY=Engineering
@FUNCTION=OCT2DEC
@SEEALSO=DEC2OCT,OCT2BIN,OCT2HEX

@CATEGORY=Engineering
@FUNCTION=OCT2HEX
@SYNTAX=OCT2HEX(x,places)
@DESCRIPTION=If @{places} is given, OCT2HEX pads the result with zeros to achieve exactly @{places} digits. If this is not possible, OCT2HEX returns #NUM!
@{x}: a octal number, either as a string or as a number
@{places}: number of digits

@SEEALSO=HEX2OCT,OCT2BIN,OCT2DEC

@CATEGORY=Erlang
@FUNCTION=DIMCIRC
@SYNTAX=DIMCIRC(traffic,gos)
@DESCRIPTION=DIMCIRC returns the number of circuits required given @{traffic} calls with grade of service @{gos}.
@{traffic}: number of calls
@{gos}: grade of service

@SEEALSO=OFFCAP,OFFTRAF,PROBBLOCK

@CATEGORY=Erlang
@FUNCTION=OFFCAP
@SYNTAX=OFFCAP(circuits,gos)
@DESCRIPTION=OFFCAP returns the traffic capacity given @{circuits} circuits with grade of service @{gos}.
@{circuits}: number of circuits
@{gos}: grade of service

@SEEALSO=DIMCIRC,OFFTRAF,PROBBLOCK

@CATEGORY=Erlang
@FUNCTION=OFFTRAF
@SYNTAX=OFFTRAF(traffic,circuits)
@DESCRIPTION=OFFTRAF returns the predicted number of offered calls given @{traffic} carried calls (taken from measurements) on @{circuits} circuits.
@{traffic}: number of carried calls
@{circuits}: number of circuits

@NOTE=@{traffic} cannot exceed @{circuits}.
@SEEALSO=PROBBLOCK,DIMCIRC,OFFCAP

@CATEGORY=Erlang
@FUNCTION=PROBBLOCK
@SYNTAX=PROBBLOCK(traffic,circuits)
@DESCRIPTION=PROBBLOCK returns probability of blocking when @{traffic} calls load into @{circuits} circuits.
@{traffic}: number of calls
@{circuits}: number of circuits

@NOTE=@{traffic} cannot exceed @{circuits}.
@SEEALSO=OFFTRAF,DIMCIRC,OFFCAP

@CATEGORY=Finance
@FUNCTION=ACCRINT
@SYNTAX=ACCRINT(issue,first_interest,settlement,rate,par,frequency,basis)
@DESCRIPTION=ACCRINT calculates the accrued interest for a security that pays periodic interest.
@{issue}: date of issue
@{first_interest}: date of first interest payment
@{settlement}: settlement date
@{rate}: nominal annual interest rate
@{par}: par value
@{frequency}: number of interest payments per year
@{basis}: calendar basis

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=ACCRINTM

@CATEGORY=Finance
@FUNCTION=ACCRINTM
@SYNTAX=ACCRINTM(issue,maturity,rate,par,basis)
@DESCRIPTION=ACCRINT calculates the accrued interest from @{issue} to @{maturity}.
@{issue}: date of issue
@{maturity}: maturity date
@{rate}: nominal annual interest rate
@{par}: par value
@{basis}: calendar basis

@NOTE=@{par} defaults to $1000.
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=ACCRINT

@CATEGORY=Finance
@FUNCTION=AMORDEGRC
@SYNTAX=AMORDEGRC(cost,purchase_date,first_period,salvage,period,rate,basis)
@DESCRIPTION=AMORDEGRC calculates the depreciation of an asset using French accounting conventions. Assets purchased in the middle of a period take prorated depreciation into account. This is similar to AMORLINC, except that a depreciation coefficient is applied in the calculation depending on the life of the assets.
@{cost}: initial cost of asset
@{purchase_date}: date of purchase
@{first_period}: end of first period
@{salvage}: value after depreciation
@{period}: subject period
@{rate}: depreciation rate
@{basis}: calendar basis

@NOTE=Named for AMORtissement DEGRessif Comptabilite.
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=AMORLINC

@CATEGORY=Finance
@FUNCTION=AMORLINC
@SYNTAX=AMORLINC(cost,purchase_date,first_period,salvage,period,rate,basis)
@DESCRIPTION=AMORLINC calculates the depreciation of an asset using French accounting conventions. Assets purchased in the middle of a period take prorated depreciation into account. 
@{cost}: initial cost of asset
@{purchase_date}: date of purchase
@{first_period}: end of first period
@{salvage}: value after depreciation
@{period}: subject period
@{rate}: depreciation rate
@{basis}: calendar basis

@NOTE=Named for AMORtissement LINeaire Comptabilite.
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=AMORDEGRC

@CATEGORY=Finance
@FUNCTION=COUPDAYBS
@SYNTAX=COUPDAYBS(settlement,maturity,frequency,basis,eom)
@DESCRIPTION=COUPDAYBS calculates the number of days from the beginning of the coupon period to the settlement date.
@{settlement}: settlement date
@{maturity}: maturity date
@{frequency}: number of interest payments per year
@{basis}: calendar basis
@{eom}: end-of-month flag

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=COUPDAYS

@CATEGORY=Finance
@FUNCTION=COUPDAYS
@SYNTAX=COUPDAYS(settlement,maturity,frequency,basis,eom)
@DESCRIPTION=COUPDAYS calculates the number of days in the coupon period of the settlement date.
@{settlement}: settlement date
@{maturity}: maturity date
@{frequency}: number of interest payments per year
@{basis}: calendar basis
@{eom}: end-of-month flag

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=COUPDAYBS,COUPDAYSNC

@CATEGORY=Finance
@FUNCTION=COUPDAYSNC
@SYNTAX=COUPDAYSNC(settlement,maturity,frequency,basis,eom)
@DESCRIPTION=COUPDAYSNC calculates number of days from the settlement date to the next coupon period.
@{settlement}: settlement date
@{maturity}: maturity date
@{frequency}: number of interest payments per year
@{basis}: calendar basis
@{eom}: end-of-month flag

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=COUPDAYS,COUPDAYBS

@CATEGORY=Finance
@FUNCTION=COUPNCD
@SYNTAX=COUPNCD(settlement,maturity,frequency,basis,eom)
@DESCRIPTION=COUPNCD calculates the coupon date following settlement.
@{settlement}: settlement date
@{maturity}: maturity date
@{frequency}: number of interest payments per year
@{basis}: calendar basis
@{eom}: end-of-month flag

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=COUPPCD,COUPDAYS,COUPDAYBS

@CATEGORY=Finance
@FUNCTION=COUPNUM
@SYNTAX=COUPNUM(settlement,maturity,frequency,basis,eom)
@DESCRIPTION=COUPNUM calculates the number of coupons to be paid between the settlement and maturity dates, rounded up.
@{settlement}: settlement date
@{maturity}: maturity date
@{frequency}: number of interest payments per year
@{basis}: calendar basis
@{eom}: end-of-month flag

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=COUPNCD,COUPPCD

@CATEGORY=Finance
@FUNCTION=COUPPCD
@SYNTAX=COUPPCD(settlement,maturity,frequency,basis,eom)
@DESCRIPTION=COUPPCD calculates the coupon date preceding settlement.
@{settlement}: settlement date
@{maturity}: maturity date
@{frequency}: number of interest payments per year
@{basis}: calendar basis
@{eom}: end-of-month flag

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=COUPNCD,COUPDAYS,COUPDAYBS

@CATEGORY=Finance
@FUNCTION=CUM_BIV_NORM_DIST
@SYNTAX=CUM_BIV_NORM_DIST(a,b,rho)
@DESCRIPTION=CUM_BIV_NORM_DIST calculates the probability that two standard normal distributed random variables with correlation @{rho} are respectively each less than @{a} and @{b}.
@{a}: limit for first random variable
@{b}: limit for second random variable
@{rho}: correlation of the two random variables


@CATEGORY=Finance
@FUNCTION=CUMIPMT
@SYNTAX=CUMIPMT(rate,nper,pv,start_period,end_period,type)
@DESCRIPTION=CUMIPMT calculates the cumulative interest paid on a loan from @{start_period} to @{end_period}.
@{rate}: effective annual interest rate
@{nper}: number of periods
@{pv}: present value
@{start_period}: first period to accumulate for
@{end_period}: last period to accumulate for
@{type}: payment type

@NOTE=If @{type} is 0, the default, payment is at the end of each period.  If @{type} is 1, payment is at the beginning of each period.
@SEEALSO=IPMT

@CATEGORY=Finance
@FUNCTION=CUMPRINC
@SYNTAX=CUMPRINC(rate,nper,pv,start_period,end_period,type)
@DESCRIPTION=CUMPRINC calculates the cumulative principal paid on a loan from @{start_period} to @{end_period}.
@{rate}: effective annual interest rate
@{nper}: number of periods
@{pv}: present value
@{start_period}: first period to accumulate for
@{end_period}: last period to accumulate for
@{type}: payment type

@NOTE=If @{type} is 0, the default, payment is at the end of each period.  If @{type} is 1, payment is at the beginning of each period.
@SEEALSO=PPMT

@CATEGORY=Finance
@FUNCTION=DB
@SYNTAX=DB(cost,salvage,life,period,month)
@DESCRIPTION=DB calculates the depreciation of an asset for a given period using the fixed-declining balance method.
@{cost}: initial cost of asset
@{salvage}: value after depreciation
@{life}: number of periods
@{period}: subject period
@{month}: number of months in first year of depreciation

@SEEALSO=DDB,SLN,SYD

@CATEGORY=Finance
@FUNCTION=DDB
@SYNTAX=DDB(cost,salvage,life,period,factor)
@DESCRIPTION=DDB calculates the depreciation of an asset for a given period using the double-declining balance method.
@{cost}: initial cost of asset
@{salvage}: value after depreciation
@{life}: number of periods
@{period}: subject period
@{factor}: factor at which the balance declines

@SEEALSO=DB,SLN,SYD

@CATEGORY=Finance
@FUNCTION=DISC
@SYNTAX=DISC(settlement,maturity,par,redemption,basis)
@DESCRIPTION=DISC calculates the discount rate for a security.
@{settlement}: settlement date
@{maturity}: maturity date
@{par}: price per $100 face value
@{redemption}: amount received at maturity
@{basis}: calendar basis

@NOTE=@{redemption} is the redemption value per $100 face value.
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=PRICEMAT

@CATEGORY=Finance
@FUNCTION=DOLLARDE
@SYNTAX=DOLLARDE(fractional_dollar,fraction)
@DESCRIPTION=DOLLARDE converts a fractional dollar amount into a decimal amount.  This is the inverse of the DOLLARFR function.
@{fractional_dollar}: amount to convert
@{fraction}: denominator

@SEEALSO=DOLLARFR

@CATEGORY=Finance
@FUNCTION=DOLLARFR
@SYNTAX=DOLLARFR(decimal_dollar,fraction)
@DESCRIPTION=DOLLARFR converts a fractional dollar amount into a fraction which is represented as the digits after the decimal point.  For example, 2/8 would be represented as .2 while 3/16 would be represented as .03.
@{decimal_dollar}: amount to convert
@{fraction}: denominator

@SEEALSO=DOLLARDE

@CATEGORY=Finance
@FUNCTION=DURATION
@SYNTAX=DURATION(settlement,maturity,coupon,yield,frequency,basis)
@DESCRIPTION=DURATION calculates the duration of a security.
@{settlement}: settlement date
@{maturity}: maturity date
@{coupon}: annual coupon rate
@{yield}: annual yield of security
@{frequency}: number of interest payments per year
@{basis}: calendar basis

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=MDURATION

@CATEGORY=Finance
@FUNCTION=EFFECT
@SYNTAX=EFFECT(rate,nper)
@DESCRIPTION=EFFECT calculates the effective interest rate using the formula (1+@{rate}/@{nper})^@{nper}-1.
@{rate}: nominal annual interest rate
@{nper}: number of periods used for compounding

@SEEALSO=NOMINAL

@CATEGORY=Finance
@FUNCTION=EURO
@SYNTAX=EURO(currency)
@DESCRIPTION=EURO calculates the national currency amount corresponding to 1 EUR for any of the national currencies that were replaced by the Euro on its introduction.
@{currency}: three-letter currency code

@NOTE=@{currency} must be one of ATS (Austria), BEF (Belgium), DEM (Germany), ESP (Spain), EUR (Euro), FIM (Finland), FRF (France), GRD (Greece), IEP (Ireland), ITL (Italy), LUF (Luxembourg), NLG (The Netherlands), or PTE (Portugal).
@NOTE=This function is not likely to be useful anymore.
@SEEALSO=EUROCONVERT

@CATEGORY=Finance
@FUNCTION=EUROCONVERT
@SYNTAX=EUROCONVERT(n,source,target)
@DESCRIPTION=EUROCONVERT converts @{n} units of currency @{source} to currency @{target}.  The rates used are the official ones used on the introduction of the Euro.
@{n}: amount
@{source}: three-letter source currency code
@{target}: three-letter target currency code

@NOTE=@{source} and @{target} must be one of the currencies listed for the EURO function.
@NOTE=This function is not likely to be useful anymore.
@SEEALSO=EURO

@CATEGORY=Finance
@FUNCTION=FV
@SYNTAX=FV(rate,nper,pmt,pv,type)
@DESCRIPTION=FV calculates the future value of @{pv} moved @{nper} periods into the future, assuming a periodic payment of @{pmt} and an interest rate of @{rate} per period.
@{rate}: effective interest rate per period
@{nper}: number of periods
@{pmt}: payment at each period
@{pv}: present value
@{type}: payment type

@NOTE=If @{type} is 0, the default, payment is at the end of each period.  If @{type} is 1, payment is at the beginning of each period.
@SEEALSO=PV

@CATEGORY=Finance
@FUNCTION=FVSCHEDULE
@SYNTAX=FVSCHEDULE(principal,schedule)
@DESCRIPTION=FVSCHEDULE calculates the future value of @{principal} after applying a range of interest rates with compounding.
@{principal}: initial value
@{schedule}: range of interest rates

@SEEALSO=FV

@CATEGORY=Finance
@FUNCTION=G_DURATION
@SYNTAX=G_DURATION(rate,pv,fv)
@DESCRIPTION=G_DURATION calculates the number of periods needed for an investment to attain a desired value.
@{rate}: effective annual interest rate
@{pv}: present value
@{fv}: future value

@SEEALSO=FV,PV

@CATEGORY=Finance
@FUNCTION=INTRATE
@SYNTAX=INTRATE(settlement,maturity,investment,redemption,basis)
@DESCRIPTION=INTRATE calculates the interest of a fully vested security.
@{settlement}: settlement date
@{maturity}: maturity date
@{investment}: amount paid on settlement
@{redemption}: amount received at maturity
@{basis}: calendar basis

@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=RECEIVED

@CATEGORY=Finance
@FUNCTION=IPMT
@SYNTAX=IPMT(rate,per,nper,pv,fv,type)
@DESCRIPTION=IPMT calculates the interest part of an annuity's payment for period number @{per}.
@{rate}: effective annual interest rate
@{per}: period number
@{nper}: number of periods
@{pv}: present value
@{fv}: future value
@{type}: payment type

@NOTE=If @{type} is 0, the default, payment is at the end of each period.  If @{type} is 1, payment is at the beginning of each period.
@SEEALSO=PPMT

@CATEGORY=Finance
@FUNCTION=IRR
@SYNTAX=IRR(values,guess)
@DESCRIPTION=IRR calculates the internal rate of return of a cash flow with periodic payments.  @{values} lists the payments (negative values) and receipts (positive values) for each period.
@{values}: cash flow
@{guess}: an estimate of what the result should be

@NOTE=The optional @{guess} is needed because there can be more than one valid result.  It defaults to 10%.
@SEEALSO=XIRR

@CATEGORY=Finance
@FUNCTION=ISPMT
@SYNTAX=ISPMT(rate,per,nper,pv)
@DESCRIPTION=ISPMT calculates the interest payment for period number @{per}.
@{rate}: effective annual interest rate
@{per}: period number
@{nper}: number of periods
@{pv}: present value

@SEEALSO=PV

@CATEGORY=Finance
@FUNCTION=MDURATION
@SYNTAX=MDURATION(settlement,maturity,coupon,yield,frequency,basis)
@DESCRIPTION=MDURATION calculates the Macauley duration of a security.
@{settlement}: settlement date
@{maturity}: maturity date
@{coupon}: annual coupon rate
@{yield}: annual yield of security
@{frequency}: number of interest payments per year
@{basis}: calendar basis

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=DURATION

@CATEGORY=Finance
@FUNCTION=MIRR
@SYNTAX=MIRR(values,finance_rate,reinvest_rate)
@DESCRIPTION=MIRR calculates the modified internal rate of return of a periodic cash flow.
@{values}: cash flow
@{finance_rate}: interest rate for financing cost
@{reinvest_rate}: interest rate for reinvestments

@SEEALSO=IRR,XIRR

@CATEGORY=Finance
@FUNCTION=NOMINAL
@SYNTAX=NOMINAL(rate,nper)
@DESCRIPTION=NOMINAL calculates the nominal interest rate from the effective rate.
@{rate}: effective annual interest rate
@{nper}: number of periods used for compounding

@SEEALSO=EFFECT

@CATEGORY=Finance
@FUNCTION=NPER
@SYNTAX=NPER(rate,pmt,pv,fv,type)
@DESCRIPTION=NPER calculates the number of periods of an investment based on periodic constant payments and a constant interest rate.
@{rate}: effective annual interest rate
@{pmt}: payment at each period
@{pv}: present value
@{fv}: future value
@{type}: payment type

@NOTE=If @{type} is 0, the default, payment is at the end of each period.  If @{type} is 1, payment is at the beginning of each period.
@SEEALSO=PV,FV

@CATEGORY=Finance
@FUNCTION=NPV
@SYNTAX=NPV(rate,value1,value2)
@DESCRIPTION=NPV calculates the net present value of a cash flow.
@{rate}: effective interest rate per period
@{value1}: cash flow for period 1
@{value2}: cash flow for period 2

@NOTE=If @{type} is 0, the default, payment is at the end of each period.  If @{type} is 1, payment is at the beginning of each period.
@SEEALSO=PV

@CATEGORY=Finance
@FUNCTION=ODDFPRICE
@SYNTAX=ODDFPRICE(settlement,maturity,issue,first_interest,rate,yield,redemption,frequency,basis)
@DESCRIPTION=ODDFPRICE calculates the price per $100 face value of a security that pays periodic interest, but has an odd first period.
@{settlement}: settlement date
@{maturity}: maturity date
@{issue}: date of issue
@{first_interest}: first interest date
@{rate}: nominal annual interest rate
@{yield}: annual yield of security
@{redemption}: amount received at maturity
@{frequency}: number of interest payments per year
@{basis}: calendar basis

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=ODDLPRICE,ODDFYIELD

@CATEGORY=Finance
@FUNCTION=ODDFYIELD
@SYNTAX=ODDFYIELD(settlement,maturity,issue,first_interest,rate,price,redemption,frequency,basis)
@DESCRIPTION=ODDFYIELD calculates the yield of a security that pays periodic interest, but has an odd first period.
@{settlement}: settlement date
@{maturity}: maturity date
@{issue}: date of issue
@{first_interest}: first interest date
@{rate}: nominal annual interest rate
@{price}: price of security
@{redemption}: amount received at maturity
@{frequency}: number of interest payments per year
@{basis}: calendar basis

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=ODDFPRICE,ODDLYIELD

@CATEGORY=Finance
@FUNCTION=ODDLPRICE
@SYNTAX=ODDLPRICE(settlement,maturity,last_interest,rate,yield,redemption,frequency,basis)
@DESCRIPTION=ODDLPRICE calculates the price per $100 face value of a security that pays periodic interest, but has an odd last period.
@{settlement}: settlement date
@{maturity}: maturity date
@{last_interest}: last interest date
@{rate}: nominal annual interest rate
@{yield}: annual yield of security
@{redemption}: amount received at maturity
@{frequency}: number of interest payments per year
@{basis}: calendar basis

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=YIELD,DURATION

@CATEGORY=Finance
@FUNCTION=ODDLYIELD
@SYNTAX=ODDLYIELD(settlement,maturity,last_interest,rate,price,redemption,frequency,basis)
@DESCRIPTION=ODDLYIELD calculates the yield of a security that pays periodic interest, but has an odd last period.
@{settlement}: settlement date
@{maturity}: maturity date
@{last_interest}: last interest date
@{rate}: nominal annual interest rate
@{price}: price of security
@{redemption}: amount received at maturity
@{frequency}: number of interest payments per year
@{basis}: calendar basis

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=YIELD,DURATION

@CATEGORY=Finance
@FUNCTION=OPT_2_ASSET_CORRELATION
@SYNTAX=OPT_2_ASSET_CORRELATION(call_put_flag,spot1,spot2,strike1,strike1,time,cost_of_carry1,cost_of_carry2,rate,volatility1,volatility2,rho)
@DESCRIPTION=OPT_2_ASSET_CORRELATION models the theoretical price of options on 2 assets with correlation @{rho}. The payoff for a call is max(@{spot2} - @{strike2},0) if @{spot1} > @{strike1} or 0 otherwise. The payoff for a put is max (@{strike2} - @{spot2}, 0) if @{spot1} < @{strike1} or 0 otherwise.
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot1}: spot price of the underlying asset of the first option
@{spot2}: spot price of the underlying asset of the second option
@{strike1}: strike prices of the first option
@{strike1}: strike prices of the second option
@{time}: time to maturity in years
@{cost_of_carry1}: net cost of holding the underlying asset of the first option (for common stocks, the risk free rate less the dividend yield)
@{cost_of_carry2}: net cost of holding the underlying asset of the second option (for common stocks, the risk free rate less the dividend yield)
@{rate}: annualized risk-free interest rate
@{volatility1}: annualized volatility in price of the underlying asset of the first option
@{volatility2}: annualized volatility in price of the underlying asset of the second option
@{rho}: correlation between the two underlying assets

@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_AMER_EXCHANGE
@SYNTAX=OPT_AMER_EXCHANGE(spot1,spot2,qty1,qty2,time,rate,cost_of_carry1,cost_of_carry2,volatility1,volatility2,rho)
@DESCRIPTION=OPT_AMER_EXCHANGE models the theoretical price of an American option to exchange one asset with quantity @{qty2} and spot price @{spot2} for another with quantity @{qty1} and spot price @{spot1}.
@{spot1}: spot price of asset 1
@{spot2}: spot price of asset 1
@{qty1}: quantity of asset 1
@{qty2}: quantity of asset 2
@{time}: time to maturity in years
@{rate}: annualized risk-free interest rate
@{cost_of_carry1}: net cost of holding asset 1 (for common stocks, the risk free rate less the dividend yield)
@{cost_of_carry2}: net cost of holding asset 2 (for common stocks, the risk free rate less the dividend yield)
@{volatility1}: annualized volatility in price of asset 1
@{volatility2}: annualized volatility in price of asset 2
@{rho}: correlation between the prices of the two assets

@SEEALSO=OPT_EURO_EXCHANGE,OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_BAW_AMER
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_BINOMIAL
@SYNTAX=OPT_BINOMIAL(amer_euro_flag,call_put_flag,num_time_steps,spot,strike,time,rate,volatility,cost_of_carry)
@DESCRIPTION=.
@{amer_euro_flag}: 'a' for an American style option or 'e' for a European style option
@{call_put_flag}: 'c' for a call and 'p' for a put
@{num_time_steps}: number of time steps used in the valuation
@{spot}: spot price
@{strike}: strike price
@{time}: time to maturity in years
@{rate}: annualized risk-free interest rate
@{volatility}: annualized volatility of the asset
@{cost_of_carry}: net cost of holding the underlying asset
@NOTE=A larger @{num_time_steps} yields greater accuracy but  OPT_BINOMIAL is slower to calculate.
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_BJER_STENS
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_BS
@SYNTAX=OPT_BS(call_put_flag,spot,strike,time,rate,volatility,cost_of_carry)
@DESCRIPTION=OPT_BS uses the Black-Scholes model to calculate the price of a European option struck at @{strike} on an asset with spot price @{spot}.
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot}: spot price
@{strike}: strike price
@{time}: time to maturity in years
@{rate}: risk-free interest rate to the exercise date in percent
@{volatility}: annualized volatility of the asset in percent for the period through to the exercise date
@{cost_of_carry}: net cost of holding the underlying asset (for common stocks, the risk free rate less the dividend yield), defaults to 0

@NOTE=The returned value will be expressed in the same units as @{strike} and @{spot}.
@SEEALSO=OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_VEGA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_BS_CARRYCOST
@SYNTAX=OPT_BS_CARRYCOST(call_put_flag,spot,strike,time,rate,volatility,cost_of_carry)
@DESCRIPTION=OPT_BS_CARRYCOST uses the Black-Scholes model to calculate the 'elasticity' of a European option struck at @{strike} on an asset with spot price @{spot}. The elasticity of an option is the rate of change of its price with respect to its @{cost_of_carry}.
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot}: spot price
@{strike}: strike price
@{time}: time to maturity in years
@{rate}: risk-free interest rate to the exercise date in percent
@{volatility}: annualized volatility of the asset in percent for the period through to the exercise date
@{cost_of_carry}: net cost of holding the underlying asset (for common stocks, the risk free rate less the dividend yield), defaults to 0

@NOTE=Elasticity is expressed as the rate of change of the option value, per 100% volatility.
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_BS_DELTA
@SYNTAX=OPT_BS_DELTA(call_put_flag,spot,strike,time,rate,volatility,cost_of_carry)
@DESCRIPTION=OPT_BS_DELTA uses the Black-Scholes model to calculate the 'delta' of a European option struck at @{strike} on an asset with spot price @{spot}.
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot}: spot price
@{strike}: strike price
@{time}: time to maturity in years
@{rate}: risk-free interest rate to the exercise date in percent
@{volatility}: annualized volatility of the asset in percent for the period through to the exercise date
@{cost_of_carry}: net cost of holding the underlying asset (for common stocks, the risk free rate less the dividend yield), defaults to 0

@NOTE=The returned value will be expressed in the same units as @{strike} and @{spot}.
@SEEALSO=OPT_BS,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_VEGA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_BS_GAMMA
@SYNTAX=OPT_BS_GAMMA(spot,strike,time,rate,volatility,cost_of_carry)
@DESCRIPTION=OPT_BS_DELTA uses the Black-Scholes model to calculate the 'gamma' of a European option struck at @{strike} on an asset with spot price @{spot}. The gamma of an option is the second derivative of its price with respect to the price of the underlying asset.
@{spot}: spot price
@{strike}: strike price
@{time}: time to maturity in years
@{rate}: risk-free interest rate to the exercise date in percent
@{volatility}: annualized volatility of the asset in percent for the period through to the exercise date
@{cost_of_carry}: net cost of holding the underlying asset (for common stocks, the risk free rate less the dividend yield), defaults to 0

@NOTE=Gamma is expressed as the rate of change of delta per unit change in @{spot}.
@NOTE=Gamma is the same for calls and puts.
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_VEGA

@CATEGORY=Finance
@FUNCTION=OPT_BS_RHO
@SYNTAX=OPT_BS_RHO(call_put_flag,spot,strike,time,rate,volatility,cost_of_carry)
@DESCRIPTION=OPT_BS_DELTA uses the Black-Scholes model to calculate the 'rho' of a European option struck at @{strike} on an asset with spot price @{spot}. The rho of an option is the rate of change of its price with respect to the risk free interest rate.
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot}: spot price
@{strike}: strike price
@{time}: time to maturity in years
@{rate}: risk-free interest rate to the exercise date in percent
@{volatility}: annualized volatility of the asset in percent for the period through to the exercise date
@{cost_of_carry}: net cost of holding the underlying asset (for common stocks, the risk free rate less the dividend yield), defaults to 0

@NOTE=Rho is expressed as the rate of change of the option value, per 100% change in @{rate}.
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_THETA,OPT_BS_VEGA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_BS_THETA
@SYNTAX=OPT_BS_THETA(call_put_flag,spot,strike,time,rate,volatility,cost_of_carry)
@DESCRIPTION=OPT_BS_DELTA uses the Black-Scholes model to calculate the 'theta' of a European option struck at @{strike} on an asset with spot price @{spot}. The theta of an option is the rate of change of its price with respect to time to expiry.
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot}: spot price
@{strike}: strike price
@{time}: time to maturity in years
@{rate}: risk-free interest rate to the exercise date in percent
@{volatility}: annualized volatility of the asset in percent for the period through to the exercise date
@{cost_of_carry}: net cost of holding the underlying asset (for common stocks, the risk free rate less the dividend yield), defaults to 0

@NOTE=Theta is expressed as the negative of the rate of change of the option value, per 365.25 days.
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_VEGA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_BS_VEGA
@SYNTAX=OPT_BS_VEGA(spot,strike,time,rate,volatility,cost_of_carry)
@DESCRIPTION=OPT_BS_DELTA uses the Black-Scholes model to calculate the 'vega' of a European option struck at @{strike} on an asset with spot price @{spot}. The vega of an option is the rate of change of its price with respect to volatility.
@{spot}: spot price
@{strike}: strike price
@{time}: time to maturity in years
@{rate}: risk-free interest rate to the exercise date in percent
@{volatility}: annualized volatility of the asset in percent for the period through to the exercise date
@{cost_of_carry}: net cost of holding the underlying asset (for common stocks, the risk free rate less the dividend yield), defaults to 0

@NOTE=Vega is the same for calls and puts.
@NOTE=Vega is expressed as the rate of change of option value, per 100% volatility.
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_COMPLEX_CHOOSER
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_EURO_EXCHANGE
@SYNTAX=OPT_EURO_EXCHANGE(spot1,spot2,qty1,qty2,time,rate,cost_of_carry1,cost_of_carry2,volatility1,volatility2,rho)
@DESCRIPTION=OPT_EURO_EXCHANGE models the theoretical price of a European option to exchange one asset with quantity @{qty2} and spot price @{spot2} for another with quantity @{qty1} and spot price @{spot1}.
@{spot1}: spot price of asset 1
@{spot2}: spot price of asset 1
@{qty1}: quantity of asset 1
@{qty2}: quantity of asset 2
@{time}: time to maturity in years
@{rate}: annualized risk-free interest rate
@{cost_of_carry1}: net cost of holding asset 1 (for common stocks, the risk free rate less the dividend yield)
@{cost_of_carry2}: net cost of holding asset 2 (for common stocks, the risk free rate less the dividend yield)
@{volatility1}: annualized volatility in price of asset 1
@{volatility2}: annualized volatility in price of asset 2
@{rho}: correlation between the prices of the two assets

@SEEALSO=OPT_AMER_EXCHANGE,OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_EXEC
@SYNTAX=OPT_EXEC(call_put_flag,spot,strike,time,rate,volatility,cost_of_carry,lambda)
@DESCRIPTION=.
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot}: spot price
@{strike}: strike price
@{time}: time to maturity in days
@{rate}: annualized risk-free interest rate
@{volatility}: annualized volatility of the asset
@{cost_of_carry}: net cost of holding the underlying asset
@{lambda}: jump rate for executives
@NOTE=The model assumes executives forfeit their options if they leave the company.
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_EXTENDIBLE_WRITER
@SYNTAX=OPT_EXTENDIBLE_WRITER(call_put_flag,spot,strike1,strike2,time1,time2,rate,cost_of_carry,volatility)
@DESCRIPTION=OPT_EXTENDIBLE_WRITER models the theoretical price of extendible writer options. These are options that have their maturity extended to @{time2} if the option is out of the money at @{time1}.
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot}: spot price
@{strike1}: strike price at which the option is struck
@{strike2}: strike price at which the option is re-struck if out of the money at @{time1}
@{time1}: initial maturity of the option in years
@{time2}: extended maturity in years if chosen
@{rate}: annualized risk-free interest rate
@{cost_of_carry}: net cost of holding the underlying asset
@{volatility}: annualized volatility of the asset

@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_FIXED_STRK_LKBK
@SYNTAX=OPT_FIXED_STRK_LKBK(call_put_flag,spot,spot_min,spot_max,strike,time,rate,cost_of_carry,volatility)
@DESCRIPTION=OPT_FIXED_STRK_LKBK determines the theoretical price of a fixed-strike lookback option where the holder of the option may exercise on expiry at the most favourable price observed during the options life of the underlying asset.
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot}: spot price
@{spot_min}: minimum spot price of the underlying asset so far observed
@{spot_max}: maximum spot price of the underlying asset so far observed
@{strike}: strike price
@{time}: time to maturity in years
@{rate}: annualized risk-free interest rate
@{cost_of_carry}: net cost of holding the underlying asset
@{volatility}: annualized volatility of the asset

@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_FLOAT_STRK_LKBK
@SYNTAX=OPT_FLOAT_STRK_LKBK(call_put_flag,spot,spot_min,spot_max,time,rate,cost_of_carry,volatility)
@DESCRIPTION=OPT_FLOAT_STRK_LKBK determines the theoretical price of a floating-strike lookback option where the holder of the option may exercise on expiry at the most favourable price observed during the options life of the underlying asset.
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot}: spot price
@{spot_min}: minimum spot price of the underlying asset so far observed
@{spot_max}: maximum spot price of the underlying asset so far observed
@{time}: time to maturity in years
@{rate}: annualized risk-free interest rate
@{cost_of_carry}: net cost of holding the underlying asset
@{volatility}: annualized volatility of the asset

@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_FORWARD_START
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_FRENCH
@SYNTAX=OPT_FRENCH(call_put_flag,spot,strike,time,ttime,rate,volatility,cost_of_carry)
@DESCRIPTION=OPT_FRENCH values the theoretical price of a European option adjusted for trading day volatility, struck at @{strike} on an asset with spot price @{spot}.
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot}: spot price
@{strike}: strike price
@{time}: ratio of the number of calendar days to exercise and the number of calendar days in the year
@{ttime}: ratio of the number of trading days to exercise and the number of trading days in the year
@{rate}: risk-free interest rate to the exercise date in percent
@{volatility}: annualized volatility of the asset in percent for the period through to the exercise date
@{cost_of_carry}: net cost of holding the underlying asset (for common stocks, the risk free rate less the dividend yield), defaults to 0

@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_GARMAN_KOHLHAGEN
@SYNTAX=OPT_GARMAN_KOHLHAGEN(call_put_flag,spot,strike,time,domestic_rate,foreign_rate,volatility)
@DESCRIPTION=OPT_GARMAN_KOHLHAGEN values the theoretical price of a European currency option struck at @{strike} on an asset with spot price @{spot}.
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot}: spot price
@{strike}: strike price
@{time}: number of days to exercise
@{domestic_rate}: domestic risk-free interest rate to the exercise date in percent
@{foreign_rate}: foreign risk-free interest rate to the exercise date in percent
@{volatility}: annualized volatility of the asset in percent for the period through to the exercise date

@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_JUMP_DIFF
@SYNTAX=OPT_JUMP_DIFF(call_put_flag,spot,strike,time,rate,volatility,lambda,gamma)
@DESCRIPTION=OPT_JUMP_DIFF models the theoretical price of an option according to the Jump Diffusion process (Merton).
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot}: spot price
@{strike}: strike price
@{time}: time to maturity in years
@{rate}: the annualized rate of interest
@{volatility}: annualized volatility of the asset in percent for the period through to the exercise date
@{lambda}: expected number of 'jumps' per year
@{gamma}: proportion of volatility explained by the 'jumps'

@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_MILTERSEN_SCHWARTZ
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_ON_OPTIONS
@SYNTAX=OPT_ON_OPTIONS(type_flag,spot,strike1,strike2,time1,time2,rate,cost_of_carry,volatility)
@DESCRIPTION=.
@{type_flag}: 'cc' for calls on calls, 'cp' for calls on puts, and so on for 'pc', and 'pp'.
@{spot}: spot price
@{strike1}: strike price at which the option being valued is struck
@{strike2}: strike price at which the underlying option is struck
@{time1}: time in years to maturity of the option
@{time2}: time in years to the maturity of the underlying option
@{rate}: annualized risk-free interest rate
@{cost_of_carry}: net cost of holding the underlying asset of the underlying option (for common stocks, the risk free rate less the dividend yield)
@{volatility}: annualized volatility in price of the underlying asset of the underlying option
@NOTE=@{time2} ≥ @{time1}
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_RGW
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_SIMPLE_CHOOSER
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_SPREAD_APPROX
@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=OPT_TIME_SWITCH
@SYNTAX=OPT_TIME_SWITCH(call_put_flag,spot,strike,a,time,m,dt,rate,cost_of_carry,volatility)
@DESCRIPTION=OPT_TIME_SWITCH models the theoretical price of time switch options. (Pechtl 1995). The holder receives @{a} * @{dt} for each period that the asset price was greater than @{strike} (for a call) or below it (for a put).
@{call_put_flag}: 'c' for a call and 'p' for a put
@{spot}: spot price
@{strike}: strike price
@{a}: amount received for each time period
@{time}: time to maturity in years
@{m}: number of time units the option has already met the condition
@{dt}: agreed upon discrete time period expressed as a fraction of a year
@{rate}: annualized risk-free interest rate
@{cost_of_carry}: net cost of holding the underlying asset
@{volatility}: annualized volatility of the asset

@SEEALSO=OPT_BS,OPT_BS_DELTA,OPT_BS_RHO,OPT_BS_THETA,OPT_BS_GAMMA

@CATEGORY=Finance
@FUNCTION=PMT
@SYNTAX=PMT(rate,nper,pv,fv,type)
@DESCRIPTION=PMT calculates the payment amount for an annuity.
@{rate}: effective annual interest rate
@{nper}: number of periods
@{pv}: present value
@{fv}: future value
@{type}: payment type

@NOTE=If @{type} is 0, the default, payment is at the end of each period.  If @{type} is 1, payment is at the beginning of each period.
@SEEALSO=PV,FV,RATE,ISPMT

@CATEGORY=Finance
@FUNCTION=PPMT
@SYNTAX=PPMT(rate,per,nper,pv,fv,type)
@DESCRIPTION=PPMT calculates the principal part of an annuity's payment for period number @{per}.
@{rate}: effective annual interest rate
@{per}: period number
@{nper}: number of periods
@{pv}: present value
@{fv}: future value
@{type}: payment type

@NOTE=If @{type} is 0, the default, payment is at the end of each period.  If @{type} is 1, payment is at the beginning of each period.
@SEEALSO=IPMT

@CATEGORY=Finance
@FUNCTION=PRICE
@SYNTAX=PRICE(settlement,maturity,rate,yield,redemption,frequency,basis)
@DESCRIPTION=PRICE calculates the price per $100 face value of a security that pays periodic interest.
@{settlement}: settlement date
@{maturity}: maturity date
@{rate}: nominal annual interest rate
@{yield}: annual yield of security
@{redemption}: amount received at maturity
@{frequency}: number of interest payments per year
@{basis}: calendar basis

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=YIELD,DURATION

@CATEGORY=Finance
@FUNCTION=PRICEDISC
@SYNTAX=PRICEDISC(settlement,maturity,discount,redemption,basis)
@DESCRIPTION=PRICEDISC calculates the price per $100 face value of a bond that does not pay interest at maturity.
@{settlement}: settlement date
@{maturity}: maturity date
@{discount}: annual rate at which to discount
@{redemption}: amount received at maturity
@{basis}: calendar basis

@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=PRICEMAT

@CATEGORY=Finance
@FUNCTION=PRICEMAT
@SYNTAX=PRICEMAT(settlement,maturity,issue,discount,yield,basis)
@DESCRIPTION=PRICEMAT calculates the price per $100 face value of a bond that pays interest at maturity.
@{settlement}: settlement date
@{maturity}: maturity date
@{issue}: date of issue
@{discount}: annual rate at which to discount
@{yield}: annual yield of security
@{basis}: calendar basis

@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=PRICEDISC

@CATEGORY=Finance
@FUNCTION=PV
@SYNTAX=PV(rate,nper,pmt,fv,type)
@DESCRIPTION=PV calculates the present value of @{fv} which is @{nper} periods into the future, assuming a periodic payment of @{pmt} and an interest rate of @{rate} per period.
@{rate}: effective interest rate per period
@{nper}: number of periods
@{pmt}: payment at each period
@{fv}: future value
@{type}: payment type

@NOTE=If @{type} is 0, the default, payment is at the end of each period.  If @{type} is 1, payment is at the beginning of each period.
@SEEALSO=FV

@CATEGORY=Finance
@FUNCTION=RATE
@SYNTAX=RATE(nper,pmt,pv,fv,type,guess)
@DESCRIPTION=RATE calculates the rate of return.
@{nper}: number of periods
@{pmt}: payment at each period
@{pv}: present value
@{fv}: future value
@{type}: payment type
@{guess}: an estimate of what the result should be

@NOTE=If @{type} is 0, the default, payment is at the end of each period.  If @{type} is 1, payment is at the beginning of each period.
@NOTE=The optional @{guess} is needed because there can be more than one valid result.  It defaults to 10%.
@SEEALSO=PV,FV

@CATEGORY=Finance
@FUNCTION=RECEIVED
@SYNTAX=RECEIVED(settlement,maturity,investment,rate,basis)
@DESCRIPTION=RECEIVED calculates the amount to be received when a security matures.
@{settlement}: settlement date
@{maturity}: maturity date
@{investment}: amount paid on settlement
@{rate}: nominal annual interest rate
@{basis}: calendar basis

@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=INTRATE

@CATEGORY=Finance
@FUNCTION=RRI
@SYNTAX=RRI(p,pv,fv)
@DESCRIPTION=RRI determines an equivalent interest rate for an investment that increases in value. The interest is compounded after each complete period.
@{p}: number of periods
@{pv}: present value
@{fv}: future value

@NOTE=If @{type} is 0, the default, payment is at the end of each period.  If @{type} is 1, payment is at the beginning of each period.
@NOTE=Note that @{p} need not be an integer but for fractional value the calculated rate is only approximate.
@SEEALSO=PV,FV,RATE

@CATEGORY=Finance
@FUNCTION=SLN
@SYNTAX=SLN(cost,salvage,life)
@DESCRIPTION=SLN calculates the depreciation of an asset using the straight-line method.
@{cost}: initial cost of asset
@{salvage}: value after depreciation
@{life}: number of periods

@SEEALSO=DB,DDB,SYD

@CATEGORY=Finance
@FUNCTION=SYD
@SYNTAX=SYD(cost,salvage,life,period)
@DESCRIPTION=SYD calculates the depreciation of an asset using the sum-of-years method.
@{cost}: initial cost of asset
@{salvage}: value after depreciation
@{life}: number of periods
@{period}: subject period

@SEEALSO=DB,DDB,SLN

@CATEGORY=Finance
@FUNCTION=TBILLEQ
@SYNTAX=TBILLEQ(settlement,maturity,discount)
@DESCRIPTION=TBILLEQ calculates the bond-equivalent yield for a treasury bill.
@{settlement}: settlement date
@{maturity}: maturity date
@{discount}: annual rate at which to discount

@SEEALSO=TBILLPRICE,TBILLYIELD

@CATEGORY=Finance
@FUNCTION=TBILLPRICE
@SYNTAX=TBILLPRICE(settlement,maturity,discount)
@DESCRIPTION=TBILLPRICE calculates the price per $100 face value for a treasury bill.
@{settlement}: settlement date
@{maturity}: maturity date
@{discount}: annual rate at which to discount

@SEEALSO=TBILLEQ,TBILLYIELD

@CATEGORY=Finance
@FUNCTION=TBILLYIELD
@SYNTAX=TBILLYIELD(settlement,maturity,price)
@DESCRIPTION=TBILLYIELD calculates the yield of a treasury bill.
@{settlement}: settlement date
@{maturity}: maturity date
@{price}: price

@SEEALSO=TBILLEQ,TBILLPRICE

@CATEGORY=Finance
@FUNCTION=VDB
@SYNTAX=VDB(cost,salvage,life,start_period,end_period,factor,no_switch)
@DESCRIPTION=VDB calculates the depreciation of an asset for a given period range using the double-declining balance method.
@{cost}: initial cost of asset
@{salvage}: value after depreciation
@{life}: number of periods
@{start_period}: first period to accumulate for
@{end_period}: last period to accumulate for
@{factor}: factor at which the balance declines
@{no_switch}: do not switch to straight-line depreciation

@NOTE=If @{no_switch} is FALSE, the calculation switches to straight-line depreciation when depreciation is greater than the declining balance calculation.
@SEEALSO=DB,DDB

@CATEGORY=Finance
@FUNCTION=XIRR
@SYNTAX=XIRR(values,dates,guess)
@DESCRIPTION=XIRR calculates the annualized internal rate of return of a cash flow at arbitrary points in time.  @{values} lists the payments (negative values) and receipts (positive values) with one value for each entry in @{dates}.
@{values}: cash flow
@{dates}: dates of cash flow
@{guess}: an estimate of what the result should be

@NOTE=The optional @{guess} is needed because there can be more than one valid result.  It defaults to 10%.
@SEEALSO=IRR

@CATEGORY=Finance
@FUNCTION=XNPV
@SYNTAX=XNPV(rate,values,dates)
@DESCRIPTION=XNPV calculates the net present value of a cash flow at irregular times
@{rate}: effective annual interest rate
@{values}: cash flow
@{dates}: dates of cash flow

@NOTE=If @{type} is 0, the default, payment is at the end of each period.  If @{type} is 1, payment is at the beginning of each period.
@SEEALSO=NPV

@CATEGORY=Finance
@FUNCTION=YIELD
@SYNTAX=YIELD(settlement,maturity,rate,price,redemption,frequency,basis)
@DESCRIPTION=YIELD calculates the yield of a security that pays periodic interest.
@{settlement}: settlement date
@{maturity}: maturity date
@{rate}: nominal annual interest rate
@{price}: price of security
@{redemption}: amount received at maturity
@{frequency}: number of interest payments per year
@{basis}: calendar basis

@NOTE=@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly).
@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=PRICE,DURATION

@CATEGORY=Finance
@FUNCTION=YIELDDISC
@SYNTAX=YIELDDISC(settlement,maturity,price,redemption,basis)
@DESCRIPTION=YIELDDISC calculates the yield of a discounted security.
@{settlement}: settlement date
@{maturity}: maturity date
@{price}: price of security
@{redemption}: amount received at maturity
@{basis}: calendar basis

@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=PRICE,DURATION

@CATEGORY=Finance
@FUNCTION=YIELDMAT
@SYNTAX=YIELDMAT(settlement,maturity,issue,rate,price,basis)
@DESCRIPTION=YIELDMAT calculates the yield of a security for which the interest is paid at maturity date.
@{settlement}: settlement date
@{maturity}: maturity date
@{issue}: date of issue
@{rate}: nominal annual interest rate
@{price}: price of security
@{basis}: calendar basis

@NOTE=If @{basis} is 0, then the US 30/360 method is used.
@NOTE=If @{basis} is 1, then actual number of days is used.
@NOTE=If @{basis} is 2, then actual number of days is used within a month, but years are considered only 360 days.
@NOTE=If @{basis} is 3, then actual number of days is used within a month, but years are always considered 365 days.
@NOTE=If @{basis} is 4, then the European 30/360 method is used.
@SEEALSO=YIELDDISC,YIELD

@CATEGORY=Gnumeric
@FUNCTION=GNUMERIC_VERSION
@SYNTAX=GNUMERIC_VERSION()
@DESCRIPTION=GNUMERIC_VERSION returns the version of gnumeric as a string.

@SEEALSO=

@CATEGORY=Information
@FUNCTION=CELL
@SYNTAX=CELL(type,cell)
@DESCRIPTION=@{type} specifies the type of information you want to obtain:
  address        		Returns the given cell reference as text.
  col            		Returns the number of the column in @{cell}.
  color          		Returns 0.
  contents       		Returns the contents of the cell in @{cell}.
  column         		Returns the number of the column in @{cell}.
  columnwidth    	Returns the column width.
  coord          		Returns the absolute address of @{cell}.
  datatype       	same as type
  filename       		Returns the name of the file of @{cell}.
  format         		Returns the code of the format of the cell.
  formulatype    	same as type
  locked         		Returns 1 if @{cell} is locked.
  parentheses    	Returns 1 if @{cell} contains a negative value
                 		and its format displays it with parentheses.
  prefix         		Returns a character indicating the horizontal
                 		alignment of @{cell}.
  prefixcharacter  	same as prefix
  protect        		Returns 1 if @{cell} is locked.
  row            		Returns the number of the row in @{cell}.
  sheetname      	Returns the name of the sheet of @{cell}.
  type           		Returns "l" if @{cell} contains a string, 
                 		"v" if it contains some other value, and 
                 		"b" if @{cell} is blank.
  value          		Returns the contents of the cell in @{cell}.
  width          		Returns the column width.
@{type}: string specifying the type of information requested
@{cell}: cell reference

@SEEALSO=INDIRECT

@CATEGORY=Information
@FUNCTION=COUNTBLANK
@SEEALSO=COUNT

@CATEGORY=Information
@FUNCTION=ERROR
@SEEALSO=ISERROR

@CATEGORY=Information
@FUNCTION=ERROR.TYPE
@SYNTAX=ERROR.TYPE(error)
@DESCRIPTION=ERROR.TYPE returns an error number corresponding to the given error value.  The error numbers for error values are:

	#DIV/0!  		2
	#VALUE!  	3
	#REF!    		4
	#NAME?   	5
	#NUM!    	6
	#N/A     		7
@{error}: an error

@SEEALSO=ISERROR

@CATEGORY=Information
@FUNCTION=EXPRESSION
@SYNTAX=EXPRESSION(cell)
@DESCRIPTION=.
@{cell}: a cell reference
@NOTE=If @{cell} contains no expression, EXPRESSION returns empty.
@SEEALSO=TEXT

@CATEGORY=Information
@FUNCTION=GET.FORMULA
@SEEALSO=EXPRESSION,ISFORMULA

@CATEGORY=Information
@FUNCTION=GETENV
@SYNTAX=GETENV(name)
@DESCRIPTION=.
@{name}: the name of the environment variable
@NOTE=If a variable called @{name} does not exist, #N/A! will be returned.
@NOTE=Variable names are case sensitive.

@CATEGORY=Information
@FUNCTION=INFO
@SYNTAX=INFO(type)
@DESCRIPTION=INFO returns information about the current operating environment according to @{type}:
  memavail     		Returns the amount of memory available, bytes.
  memused      	Returns the amount of memory used (bytes).
  numfile      		Returns the number of active worksheets.
  osversion    		Returns the operating system version.
  recalc       		Returns the recalculation mode (automatic).
  release      		Returns the version of Gnumeric as text.
  system       		Returns the name of the environment.
  totmem       		Returns the amount of total memory available.
@{type}: string giving the type of information requested

@SEEALSO=CELL

@CATEGORY=Information
@FUNCTION=ISBLANK
@SYNTAX=ISBLANK(value)
@DESCRIPTION=This function checks if a value is blank.  Empty cells are blank, but empty strings are not.
@{value}: a value


@CATEGORY=Information
@FUNCTION=ISERR
@SEEALSO=ISERROR

@CATEGORY=Information
@FUNCTION=ISERROR
@SEEALSO=ISERR,ISNA

@CATEGORY=Information
@FUNCTION=ISEVEN
@SEEALSO=ISODD

@CATEGORY=Information
@FUNCTION=ISFORMULA
@SEEALSO=GET.FORMULA

@CATEGORY=Information
@FUNCTION=ISLOGICAL
@SYNTAX=ISLOGICAL(value)
@DESCRIPTION=This function checks if a value is either TRUE or FALSE.
@{value}: a value


@CATEGORY=Information
@FUNCTION=ISNA
@SEEALSO=NA

@CATEGORY=Information
@FUNCTION=ISNONTEXT
@SEEALSO=ISTEXT

@CATEGORY=Information
@FUNCTION=ISNUMBER
@SYNTAX=ISNUMBER(value)
@DESCRIPTION=This function checks if a value is a number.  Neither TRUE nor FALSE are numbers for this purpose.
@{value}: a value


@CATEGORY=Information
@FUNCTION=ISODD
@SEEALSO=ISEVEN

@CATEGORY=Information
@FUNCTION=ISREF
@SYNTAX=ISREF(value)
@DESCRIPTION=This function checks if a value is a cell reference.
@{value}: a value


@CATEGORY=Information
@FUNCTION=ISTEXT
@SEEALSO=ISNONTEXT

@CATEGORY=Information
@FUNCTION=N
@SYNTAX=N(text)
@DESCRIPTION=.
@{text}: string
@NOTE=If @{text} contains non-numerical text, 0 is returned.

@CATEGORY=Information
@FUNCTION=NA
@SEEALSO=ISNA

@CATEGORY=Information
@FUNCTION=TYPE
@SYNTAX=TYPE(value)
@DESCRIPTION=TYPE returns a number indicating the data type of @{ value}:
1  	= number
2  	= text
4  	= boolean
16 	= error
64 	= array
@{value}: a value


@CATEGORY=Logic
@FUNCTION=AND
@SYNTAX=AND(b0,b1)
@DESCRIPTION=AND calculates the logical conjunction of its arguments @{b0},@{b1},...
@{b0}: logical value
@{b1}: logical value

@NOTE=If an argument is numerical, zero is considered FALSE and anything else TRUE.
@NOTE=Strings and empty values are ignored.
@NOTE=If no logical values are provided, then the error #VALUE! is returned.
@NOTE=This function is strict: if any argument is an error, the result will be the first such error.
@SEEALSO=OR,NOT,IF

@CATEGORY=Logic
@FUNCTION=FALSE
@SYNTAX=FALSE()
@DESCRIPTION=FALSE returns the value FALSE.

@SEEALSO=TRUE,IF

@CATEGORY=Logic
@FUNCTION=IF
@SYNTAX=IF(cond,trueval,falseval)
@DESCRIPTION=This function first evaluates the condition.  If the result is true, it will then evaluate and return the second argument.  Otherwise, it will evaluate and return the last argument.
@{cond}: condition.
@{trueval}: value to use if condition is true.
@{falseval}: value to use if condition is false.

@SEEALSO=AND,OR,XOR,NOT,IFERROR

@CATEGORY=Logic
@FUNCTION=IFERROR
@SYNTAX=IFERROR(x,y)
@DESCRIPTION=This function returns the first value, unless that is an error, in which case it returns the second.
@{x}: value to test for error.
@{y}: alternate value.

@SEEALSO=IF,ISERROR

@CATEGORY=Logic
@FUNCTION=IFNA
@SYNTAX=IFNA(x,y)
@DESCRIPTION=This function returns the first value, unless that is #NA!, in which case it returns the second.
@{x}: value to test for #NA! error.
@{y}: alternate value.

@SEEALSO=IF,ISERROR

@CATEGORY=Logic
@FUNCTION=NOT
@SYNTAX=NOT(b)
@DESCRIPTION=NOT calculates the logical negation of its argument.
@{b}: logical value

@NOTE=If the argument is numerical, zero is considered FALSE and anything else TRUE.
@NOTE=Strings and empty values are ignored.
@SEEALSO=AND,OR,IF

@CATEGORY=Logic
@FUNCTION=OR
@SYNTAX=OR(b0,b1)
@DESCRIPTION=OR calculates the logical disjunction of its arguments @{b0},@{b1},...
@{b0}: logical value
@{b1}: logical value

@NOTE=If an argument is numerical, zero is considered FALSE and anything else TRUE.
@NOTE=Strings and empty values are ignored.
@NOTE=If no logical values are provided, then the error #VALUE! is returned.
@NOTE=This function is strict: if any argument is an error, the result will be the first such error.
@SEEALSO=AND,XOR,NOT,IF

@CATEGORY=Logic
@FUNCTION=TRUE
@SYNTAX=TRUE()
@DESCRIPTION=TRUE returns the value TRUE.

@SEEALSO=FALSE,IF

@CATEGORY=Logic
@FUNCTION=XOR
@SYNTAX=XOR(b0,b1)
@DESCRIPTION=XOR calculates the logical exclusive disjunction of its arguments @{b0},@{b1},...
@{b0}: logical value
@{b1}: logical value

@NOTE=If an argument is numerical, zero is considered FALSE and anything else TRUE.
@NOTE=Strings and empty values are ignored.
@NOTE=If no logical values are provided, then the error #VALUE! is returned.
@NOTE=This function is strict: if any argument is an error, the result will be the first such error.
@SEEALSO=OR,AND,NOT,IF

@CATEGORY=Lookup
@FUNCTION=ADDRESS
@SYNTAX=ADDRESS(row_num,col_num,abs_num,a1,text)
@DESCRIPTION=.
@{row_num}: row number
@{col_num}: column number
@{abs_num}: 1 for an absolute, 2 for a row absolute and column relative, 3 for a row relative and column absolute, and 4 for a relative reference; defaults to 1
@{a1}: if TRUE, an A1-style reference is provided, otherwise an R1C1-style reference; defaults to TRUE
@{text}: name of the worksheet, defaults to no sheet
@NOTE=If @{row_num} or @{col_num} is less than one, ADDRESS returns #VALUE!
@NOTE=If @{abs_num} is greater than 4 ADDRESS returns #VALUE!
@SEEALSO=COLUMNNUMBER

@CATEGORY=Lookup
@FUNCTION=AREAS
@SEEALSO=ADDRESS,INDEX,INDIRECT,OFFSET

@CATEGORY=Lookup
@FUNCTION=CHOOSE
@SYNTAX=CHOOSE(index,value1,value2)
@DESCRIPTION=CHOOSE returns its (@{index}+1)th argument.
@{index}: positive number
@{value1}: first value
@{value2}: second value

@NOTE=@{index} is truncated to an integer. If @{index} < 1 or the truncated @{index} > number of values, CHOOSE returns #VALUE!
@SEEALSO=IF

@CATEGORY=Lookup
@FUNCTION=COLUMN
@SYNTAX=COLUMN(x)
@DESCRIPTION=COLUMN function returns a Nx1 array containing the sequence of integers from the first column to the last column of @{reference}.
@{x}: reference, defaults to the position of the current expression

@NOTE=If @{reference} is neither an array nor a reference nor a range, returns #VALUE!
@SEEALSO=COLUMNS,ROW,ROWS

@CATEGORY=Lookup
@FUNCTION=COLUMNNUMBER
@SYNTAX=COLUMNNUMBER(name)
@DESCRIPTION=.
@{name}: column name such as "IV"
@NOTE=If @{name} is invalid, COLUMNNUMBER returns #VALUE!
@SEEALSO=ADDRESS

@CATEGORY=Lookup
@FUNCTION=COLUMNS
@SYNTAX=COLUMNS(reference)
@DESCRIPTION=.
@{reference}: array or area
@NOTE=If @{reference} is neither an array nor a reference nor a range, COLUMNS returns #VALUE!
@SEEALSO=COLUMN,ROW,ROWS

@CATEGORY=Lookup
@FUNCTION=HLOOKUP
@SYNTAX=HLOOKUP(value,range,row,approximate,as_index)
@DESCRIPTION=HLOOKUP function finds the row in @{range} that has a first cell similar to @{value}.  If @{approximate} is not true it finds the row with an exact equality. If @{approximate} is true, it finds the last row with first value less than or equal to @{value}. If @{as_index} is true the 0-based row offset is returned.
@{value}: search value
@{range}: range to search
@{row}: 1-based column offset indicating the return values 
@{approximate}: if false, an exact match of @{value} must be found; defaults to TRUE
@{as_index}: if true, the 0-based row offset is returned; defaults to FALSE

@NOTE=If @{approximate} is true, then the values must be sorted in order of ascending value.
@NOTE=HLOOKUP returns #REF! if @{row} falls outside @{range}.
@SEEALSO=VLOOKUP

@CATEGORY=Lookup
@FUNCTION=HYPERLINK
@SYNTAX=HYPERLINK(link_location,label)
@DESCRIPTION=HYPERLINK function currently returns its 2nd argument, or if that is omitted the 1st argument.
@{link_location}: string
@{label}: string, optional


@CATEGORY=Lookup
@FUNCTION=INDEX
@SYNTAX=INDEX(array,row,col,area)
@DESCRIPTION=INDEX gives a reference to a cell in the given @{array}. The cell is selected by @{row} and @{col}, which count the rows and columns in the array.
@{array}: 
@{row}: desired row, defaults to 1
@{col}: desired column, defaults to 1
@{area}: from which area to select a cell, defaults to 1

@NOTE=If the reference falls outside the range of @{array}, INDEX returns #REF!

@CATEGORY=Lookup
@FUNCTION=INDIRECT
@SYNTAX=INDIRECT(ref_text,format)
@DESCRIPTION=.
@{ref_text}: 
@{format}: if true, @{ref_text} is given in A1-style, otherwise it is given in R1C1 style; defaults to true
@NOTE=If @{ref_text} is not a valid reference in the style determined by @{format}, INDIRECT returns #REF!
@SEEALSO=AREAS,INDEX,CELL

@CATEGORY=Lookup
@FUNCTION=LOOKUP
@SYNTAX=LOOKUP(value,vector1,vector2)
@DESCRIPTION=If  @{vector1} has more rows than columns, LOOKUP searches the first row of @{vector1}, otherwise the first column. If @{vector2} is omitted the return value is taken from the last row or column of @{vector1}.
@{value}: value to look up
@{vector1}: range to search:
@{vector2}: range of return values

@NOTE=If LOOKUP can't find @{value} it uses the largest value less than @{value}.
@NOTE=The data must be sorted.
@NOTE=If @{value} is smaller than the first value it returns #N/A.
@NOTE=If the corresponding location does not exist in @{vector2}, it returns #N/A.
@SEEALSO=VLOOKUP,HLOOKUP

@CATEGORY=Lookup
@FUNCTION=MATCH
@SYNTAX=MATCH(seek,vector,type)
@DESCRIPTION=MATCH searches @{vector} for @{seek} and returns the 1-based index.
@{seek}: value to find
@{vector}: n by 1 or 1 by n range to be searched
@{type}: +1 to find the largest value ≤ @{seek}, 0 to find the first value = @{seek}, or-1 to find the smallest value ≥ @{seek}

@NOTE= For @{type} = -1 the data must be sorted in descending order; for @{type} = +1 the data must be sorted in ascending order.
@NOTE=If @{seek} could not be found, #N/A is returned.
@NOTE=If @{vector} is neither n by 1 nor 1 by n, #N/A is returned.
@SEEALSO=LOOKUP

@CATEGORY=Lookup
@FUNCTION=OFFSET
@SYNTAX=OFFSET(range,row,col,height,width)
@DESCRIPTION=OFFSET returns the cell range starting at offset (@{row},@{col}) from @{range} of height @{height} and width @{width}.
@{range}: reference or range
@{row}: number of rows to offset @{range}
@{col}: number of columns to offset @{range}
@{height}: height of the offset range, defaults to height of @{range}
@{width}: width of the offset range, defaults to width of @{range}

@NOTE=If @{range} is neither a reference nor a range, OFFSET returns #VALUE!
@SEEALSO=COLUMN,COLUMNS,ROWS,INDEX,INDIRECT,ADDRESS

@CATEGORY=Lookup
@FUNCTION=ROW
@SYNTAX=ROW(x)
@DESCRIPTION=ROW function returns a 1xN array containing the sequence of integers from the first row to the last row of @{reference}.
@{x}: reference, defaults to the position of the current expression

@NOTE=If @{reference} is neither an array nor a reference nor a range, returns #VALUE!
@SEEALSO=COLUMN,COLUMNS,ROWS

@CATEGORY=Lookup
@FUNCTION=ROWS
@SYNTAX=ROWS(reference)
@DESCRIPTION=.
@{reference}: array, reference, or range
@NOTE=If @{reference} is neither an array nor a reference nor a range, ROWS returns #VALUE!
@SEEALSO=COLUMN,COLUMNS,ROW

@CATEGORY=Lookup
@FUNCTION=SHEET
@SYNTAX=SHEET(reference)
@DESCRIPTION=.
@{reference}: reference or literal sheet name, defaults to the current sheet
@NOTE=If @{reference} is neither a reference nor a literal sheet name, SHEETS returns #VALUE!
@SEEALSO=SHEETS,ROW,COLUMNNUMBER

@CATEGORY=Lookup
@FUNCTION=SHEETS
@SYNTAX=SHEETS(reference)
@DESCRIPTION=.
@{reference}: array, reference, or range, defaults to the maximum range
@NOTE=If @{reference} is neither an array nor a reference nor a range, SHEETS returns #VALUE!
@SEEALSO=COLUMNS,ROWS

@CATEGORY=Lookup
@FUNCTION=TRANSPOSE
@SEEALSO=MMULT

@CATEGORY=Lookup
@FUNCTION=VLOOKUP
@SYNTAX=VLOOKUP(value,range,column,approximate,as_index)
@DESCRIPTION=VLOOKUP function finds the row in @{range} that has a first cell similar to @{value}.  If @{approximate} is not true it finds the row with an exact equality. If @{approximate} is true, it finds the last row with first value less than or equal to @{value}. If @{as_index} is true the 0-based row offset is returned.
@{value}: search value
@{range}: range to search
@{column}: 1-based column offset indicating the return values
@{approximate}: if false, an exact match of @{value} must be found; defaults to TRUE
@{as_index}: if true, the 0-based row offset is returned; defaults to FALSE

@NOTE=If @{approximate} is true, then the values must be sorted in order of ascending value.
@NOTE=VLOOKUP returns #REF! if @{row} falls outside @{range}.
@SEEALSO=HLOOKUP

@CATEGORY=Mathematics
@FUNCTION=ABS
@SYNTAX=ABS(x)
@DESCRIPTION=ABS gives the absolute value of @{x}, i.e. the non-negative number of the same magnitude as @{x}.
@{x}: number

@SEEALSO=CEIL, CEILING, FLOOR, INT, MOD

@CATEGORY=Mathematics
@FUNCTION=ACOS
@SEEALSO=COS, SIN, DEGREES, RADIANS

@CATEGORY=Mathematics
@FUNCTION=ACOSH
@SEEALSO=ACOS,ASINH,DEGREES,RADIANS 

@CATEGORY=Mathematics
@FUNCTION=ACOT
@SEEALSO=COT,TAN

@CATEGORY=Mathematics
@FUNCTION=ACOTH
@SEEALSO=COTH,TANH

@CATEGORY=Mathematics
@FUNCTION=Arabic
@SYNTAX=Arabic(roman)
@DESCRIPTION=Any Roman symbol to the left of a larger symbol (directly or indirectly) reduces the final value by the symbol amount, otherwise, it increases the final amount by the symbol's amount.
@{roman}: Roman numeral

@SEEALSO=ROMAN

@CATEGORY=Mathematics
@FUNCTION=ASIN
@SYNTAX=ASIN(x)
@DESCRIPTION=ASIN calculates the arc sine of @{x}; that is the value whose sine is @{x}.
@{x}: number

@NOTE=If @{x} falls outside the range -1 to 1, ASIN returns #NUM!
@SEEALSO=SIN,COS,ASINH,DEGREES,RADIANS

@CATEGORY=Mathematics
@FUNCTION=ASINH
@SYNTAX=ASINH(x)
@DESCRIPTION=ASINH calculates the inverse hyperbolic sine of @{x}; that is the value whose hyperbolic sine is @{x}.
@{x}: number

@SEEALSO=ASIN,ACOSH,SIN,COS,DEGREES,RADIANS

@CATEGORY=Mathematics
@FUNCTION=ATAN
@SYNTAX=ATAN(x)
@DESCRIPTION=ATAN calculates the arc tangent of @{x}; that is the value whose tangent is @{x}.
@{x}: angle in radians

@SEEALSO=TAN,COS,SIN,DEGREES,RADIANS

@CATEGORY=Mathematics
@FUNCTION=ATAN2
@SYNTAX=ATAN2(b1,b2)
@DESCRIPTION=ATAN2 calculates the arc tangent of the ratio @{b1}/@{b2} with the sign according to the quadrant containing (@{b1},@{b2}).
@{b1}: angle in radians
@{b2}: angle in radians

@SEEALSO=ATAN,ATANH,COS,SIN,DEGREES,RADIANS

@CATEGORY=Mathematics
@FUNCTION=ATANH
@SYNTAX=ATANH(x)
@DESCRIPTION=ATANH calculates the inverse hyperbolic tangent of @{x}; that is the value whose hyperbolic tangent is @{x}.
@{x}: angle in radians

@NOTE=If the absolute value of @{x} is greater than 1.0, ATANH returns #NUM!
@SEEALSO=ATAN,COS,SIN,DEGREES,RADIANS

@CATEGORY=Mathematics
@FUNCTION=AVERAGEIF
@SEEALSO=SUMIF,COUNTIF

@CATEGORY=Mathematics
@FUNCTION=BETA
@SYNTAX=BETA(x,y)
@DESCRIPTION=BETA function returns the value of the Euler beta function extended to all real numbers except 0 and negative integers.
@{x}: number
@{y}: number

@NOTE=If @{x}, @{y}, or (@{x} + @{y}) are non-positive integers, BETA returns #NUM!
@SEEALSO=BETALN,GAMMALN

@CATEGORY=Mathematics
@FUNCTION=BETALN
@SYNTAX=BETALN(x,y)
@DESCRIPTION=BETALN function returns the natural logarithm of the absolute value of the Euler beta function extended to all real numbers except 0 and negative integers.
@{x}: number
@{y}: number

@NOTE=If @{x}, @{y}, or (@{x} + @{y}) are non-positive integers, BETALN returns #NUM!
@SEEALSO=BETA,GAMMALN

@CATEGORY=Mathematics
@FUNCTION=CEIL
@SYNTAX=CEIL(x)
@DESCRIPTION=CEIL(@{x}) is the smallest integer that is at least as large as @{x}.
@{x}: number

@SEEALSO=CEILING,FLOOR,ABS,INT,MOD

@CATEGORY=Mathematics
@FUNCTION=CEILING
@SYNTAX=CEILING(x,significance)
@DESCRIPTION=CEILING(@{x},@{significance}) is the nearest multiple of @{significance} whose absolute value is at least ABS(@{x}).
@{x}: number
@{significance}: base multiple (defaults to 1 for @{x} > 0 and -1 for @{x} <0)

@NOTE=If @{x} or @{significance} is non-numeric, CEILING returns a #VALUE! error.
@NOTE=If @{x} and @{significance} have different signs, CEILING returns a #NUM! error.
@SEEALSO=CEIL,FLOOR,ABS,INT,MOD

@CATEGORY=Mathematics
@FUNCTION=CHOLESKY
@SYNTAX=CHOLESKY(matrix)
@DESCRIPTION=.
@{matrix}: a symmetric positive definite matrix
@NOTE=If the Cholesky-Banachiewicz algorithm applied to @{matrix} fails, Cholesky returns #NUM!
@NOTE=If @{matrix} does not contain an equal number of columns and rows, CHOLESKY returns #VALUE!
@SEEALSO=MINVERSE,MMULT,MDETERM

@CATEGORY=Mathematics
@FUNCTION=COMBIN
@SYNTAX=COMBIN(n,k)
@DESCRIPTION=COMBIN returns the binomial coefficient "@{n} choose @{k}", the number of @{k}-combinations of an @{n}-element set without repetition.
@{n}: non-negative integer
@{k}: non-negative integer

@NOTE=If @{n} is less than @{k} COMBIN returns #NUM!

@CATEGORY=Mathematics
@FUNCTION=COMBINA
@SEEALSO=COMBIN

@CATEGORY=Mathematics
@FUNCTION=COS
@SYNTAX=COS(x)
@DESCRIPTION=This function is Excel compatible.
@{x}: angle in radians

@SEEALSO=SIN,TAN,SINH,COSH,TANH,RADIANS,DEGREES

@CATEGORY=Mathematics
@FUNCTION=COSH
@SEEALSO=SIN,TAN,SINH,COSH,TANH,RADIANS,DEGREES

@CATEGORY=Mathematics
@FUNCTION=COT
@SEEALSO=TAN,ACOT

@CATEGORY=Mathematics
@FUNCTION=COTH
@SEEALSO=TANH,ACOTH

@CATEGORY=Mathematics
@FUNCTION=COUNTIF
@SEEALSO=COUNT,SUMIF

@CATEGORY=Mathematics
@FUNCTION=CSC
@SEEALSO=SIN,COS,TAN,SEC,SINH,COSH,TANH,RADIANS,DEGREES

@CATEGORY=Mathematics
@FUNCTION=CSCH
@SEEALSO=SIN,COS,TAN,CSC,SEC,SINH,COSH,TANH,RADIANS,DEGREES

@CATEGORY=Mathematics
@FUNCTION=DEGREES
@SEEALSO=RADIANS,PI

@CATEGORY=Mathematics
@FUNCTION=EVEN
@SEEALSO=ODD

@CATEGORY=Mathematics
@FUNCTION=EXP
@SYNTAX=EXP(x)
@DESCRIPTION=.
@{x}: number
@NOTE=e is the base of the natural logarithm.
@SEEALSO=LOG, LOG2, LOG10

@CATEGORY=Mathematics
@FUNCTION=EXPM1
@SYNTAX=EXPM1(x)
@DESCRIPTION=.
@{x}: number
@NOTE=This function has a higher resulting precision than evaluating EXP(@{x})-1.
@SEEALSO=EXP, LN1P

@CATEGORY=Mathematics
@FUNCTION=FACT
@SYNTAX=FACT(x)
@DESCRIPTION=.
@{x}: number
@NOTE=The domain of this function has been extended using the GAMMA function.

@CATEGORY=Mathematics
@FUNCTION=FACTDOUBLE
@SYNTAX=FACTDOUBLE(x)
@DESCRIPTION=FACTDOUBLE function returns the double factorial @{x}!!
@{x}: non-negative integer

@NOTE=If @{x} is not an integer, it is truncated. If @{x} is negative, FACTDOUBLE returns #NUM!
@SEEALSO=FACT

@CATEGORY=Mathematics
@FUNCTION=FIB
@SYNTAX=FIB(n)
@DESCRIPTION=FIB(@{n}) is the @{n}th Fibonacci number.
@{n}: positive integer

@NOTE=If @{n} is not an integer, it is truncated. If it is negative or zero FIB returns #NUM!

@CATEGORY=Mathematics
@FUNCTION=FLOOR
@SYNTAX=FLOOR(x,significance)
@DESCRIPTION=FLOOR(@{x},@{significance}) is the nearest multiple of @{significance} whose absolute value is at most ABS(@{x})
@{x}: number.
@{significance}: base multiple (defaults to 1 for @{x} > 0 and -1 for @{x} <0)

@SEEALSO=CEIL,CEILING,ABS,INT,MOD

@CATEGORY=Mathematics
@FUNCTION=G_PRODUCT
@SYNTAX=G_PRODUCT(x1,x2)
@DESCRIPTION=.
@{x1}: number
@{x2}: number
@NOTE=Empty cells are ignored and the empty product is 1.
@SEEALSO=SUM, COUNT

@CATEGORY=Mathematics
@FUNCTION=GAMMA
@SEEALSO=GAMMALN

@CATEGORY=Mathematics
@FUNCTION=GAMMALN
@SEEALSO=GAMMA

@CATEGORY=Mathematics
@FUNCTION=GCD
@SYNTAX=GCD(n0,n1)
@DESCRIPTION=GCD calculates the greatest common divisor of the given numbers @{n0},@{n1},..., the greatest integer that is a divisor of each argument.
@{n0}: positive integer
@{n1}: positive integer

@NOTE=If any of the arguments is not an integer, it is truncated.
@SEEALSO=LCM

@CATEGORY=Mathematics
@FUNCTION=GD
@SEEALSO=TAN,TANH

@CATEGORY=Mathematics
@FUNCTION=HYPOT
@SEEALSO=MIN,MAX

@CATEGORY=Mathematics
@FUNCTION=INT
@SEEALSO=CEIL,CEILING,FLOOR,ABS,MOD

@CATEGORY=Mathematics
@FUNCTION=LCM
@SYNTAX=LCM(n0,n1)
@DESCRIPTION=LCM calculates the least common multiple of the given numbers @{n0},@{n1},..., the smallest integer that is a multiple of each argument.
@{n0}: positive integer
@{n1}: positive integer

@NOTE=If any of the arguments is not an integer, it is truncated.
@SEEALSO=GCD

@CATEGORY=Mathematics
@FUNCTION=LN
@SYNTAX=LN(x)
@DESCRIPTION=.
@{x}: positive number
@NOTE=If @{x} ≤ 0, LN returns #NUM! error.
@SEEALSO=EXP,LOG2,LOG10

@CATEGORY=Mathematics
@FUNCTION=LN1P
@SYNTAX=LN1P(x)
@DESCRIPTION=LN1P calculates LN(1+@{x}) but yielding a higher precision than evaluating LN(1+@{x}).
@{x}: positive number

@NOTE=If @{x} ≤ -1, LN returns #NUM! error.
@SEEALSO=EXP,LN,EXPM1

@CATEGORY=Mathematics
@FUNCTION=LOG
@SYNTAX=LOG(x,base)
@DESCRIPTION=.
@{x}: positive number
@{base}: base of the logarithm, defaults to 10
@NOTE=@{base} must be positive and not equal to 1.
@NOTE=If @{x} ≤ 0, LOG returns #NUM! error.
@SEEALSO=LN,LOG2,LOG10

@CATEGORY=Mathematics
@FUNCTION=LOG10
@SYNTAX=LOG10(x)
@DESCRIPTION=.
@{x}: positive number
@NOTE=If @{x} ≤ 0, LOG10 returns #NUM!
@SEEALSO=EXP,LOG2,LOG

@CATEGORY=Mathematics
@FUNCTION=LOG2
@SYNTAX=LOG2(x)
@DESCRIPTION=.
@{x}: positive number
@NOTE=If @{x} ≤ 0, LOG2 returns #NUM!
@SEEALSO=EXP,LOG10,LOG

@CATEGORY=Mathematics
@FUNCTION=MDETERM
@SEEALSO=MMULT, MINVERSE

@CATEGORY=Mathematics
@FUNCTION=MINVERSE
@SYNTAX=MINVERSE(matrix)
@DESCRIPTION=.
@{matrix}: a square matrix
@NOTE=If @{matrix} is not invertible, MINVERSE returns #NUM!
@NOTE=If @{matrix} does not contain an equal number of columns and rows, MINVERSE returns #VALUE!
@SEEALSO=MMULT, MDETERM

@CATEGORY=Mathematics
@FUNCTION=MMULT
@SEEALSO=TRANSPOSE,MINVERSE

@CATEGORY=Mathematics
@FUNCTION=MOD
@SYNTAX=MOD(x,n)
@DESCRIPTION=MOD function returns the remainder when @{x} is divided by @{n}.
@{x}: integer
@{n}: integer

@NOTE=If @{n} is 0, MOD returns #DIV/0!
@SEEALSO=CEIL,CEILING,FLOOR,ABS,INT,ABS

@CATEGORY=Mathematics
@FUNCTION=MROUND
@SYNTAX=MROUND(x,m)
@DESCRIPTION=.
@{x}: number
@{m}: number
@NOTE=If @{x} and @{m} have different sign, MROUND returns #NUM!
@SEEALSO=ROUNDDOWN,ROUND,ROUNDUP

@CATEGORY=Mathematics
@FUNCTION=MULTINOMIAL
@SEEALSO=COMBIN,SUM

@CATEGORY=Mathematics
@FUNCTION=MUNIT
@SEEALSO=MMULT,MDETERM,MINVERSE

@CATEGORY=Mathematics
@FUNCTION=ODD
@SEEALSO=EVEN

@CATEGORY=Mathematics
@FUNCTION=PI
@SEEALSO=SQRTPI

@CATEGORY=Mathematics
@FUNCTION=POWER
@SYNTAX=POWER(x,y)
@DESCRIPTION=.
@{x}: number
@{y}: number
@NOTE=If both @{x} and @{y} equal 0, POWER returns #NUM!
@NOTE=If @{x} = 0 and @{y} < 0, POWER returns #DIV/0!
@NOTE=If @{x} < 0 and @{y} is not an integer, POWER returns #NUM!
@SEEALSO=EXP

@CATEGORY=Mathematics
@FUNCTION=PRODUCT
@SYNTAX=PRODUCT(values)
@DESCRIPTION=Product computes the product of all the values and cells referenced in the argument list.
@{values}: a list of values to multiply

@NOTE=If all cells are empty, the result will be 0.
@SEEALSO=SUM,COUNT,G_PRODUCT

@CATEGORY=Mathematics
@FUNCTION=QUOTIENT
@SYNTAX=QUOTIENT(numerator,denominator)
@DESCRIPTION=QUOTIENT yields the integer portion of the division @{numerator}/@{denominator}.
QUOTIENT (@{numerator},@{denominator})⨉@{denominator}+MOD(@{numerator},@{denominator})=@{numerator}
@{numerator}: integer
@{denominator}: non-zero integer

@SEEALSO=MOD

@CATEGORY=Mathematics
@FUNCTION=RADIANS
@SEEALSO=PI,DEGREES

@CATEGORY=Mathematics
@FUNCTION=ROMAN
@SYNTAX=ROMAN(n,type)
@DESCRIPTION=ROMAN returns the arabic number @{n} as a roman numeral text.
If @{type} is 0 or it is omitted, ROMAN returns classic roman numbers.
Type 1 is more concise than classic type, type 2 is more concise than type 1, and type 3 is more concise than type 2. Type 4 is a simplified type.
@{n}: non-negative integer
@{type}: 0,1,2,3,or 4, defaults to 0


@CATEGORY=Mathematics
@FUNCTION=ROUND
@SYNTAX=ROUND(x,d)
@DESCRIPTION=If @{d} is greater than zero, @{x} is rounded to the given number of digits.
If @{d} is zero, @{x} is rounded to the next integer.
If @{d} is less than zero, @{x} is rounded to the left of the decimal point
@{x}: number
@{d}: integer, defaults to 0

@SEEALSO=ROUNDDOWN,ROUNDUP

@CATEGORY=Mathematics
@FUNCTION=ROUNDDOWN
@SYNTAX=ROUNDDOWN(x,d)
@DESCRIPTION=If @{d} is greater than zero, @{x} is rounded toward 0 to the given number of digits.
If @{d} is zero, @{x} is rounded toward 0 to the next integer.
If @{d} is less than zero, @{x} is rounded toward 0 to the left of the decimal point
@{x}: number
@{d}: integer, defaults to 0

@SEEALSO=ROUND,ROUNDUP

@CATEGORY=Mathematics
@FUNCTION=ROUNDUP
@SYNTAX=ROUNDUP(x,d)
@DESCRIPTION=If @{d} is greater than zero, @{x} is rounded away from 0 to the given number of digits.
If @{d} is zero, @{x} is rounded away from 0 to the next integer.
If @{d} is less than zero, @{x} is rounded away from 0 to the left of the decimal point
@{x}: number
@{d}: integer, defaults to 0

@SEEALSO=ROUND,ROUNDDOWN,INT

@CATEGORY=Mathematics
@FUNCTION=SEC
@SEEALSO=SIN,COS,TAN,CSC,SINH,COSH,TANH,RADIANS,DEGREES

@CATEGORY=Mathematics
@FUNCTION=SECH
@SEEALSO=SIN,COS,TAN,CSC,SEC,SINH,COSH,TANH,RADIANS,DEGREES

@CATEGORY=Mathematics
@FUNCTION=SERIESSUM
@SEEALSO=COUNT,SUM

@CATEGORY=Mathematics
@FUNCTION=SIGN
@SYNTAX=SIGN(x)
@DESCRIPTION=SIGN returns 1 if the @{x} is positive and it returns -1 if @{x} is negative.
@{x}: number

@SEEALSO=ABS

@CATEGORY=Mathematics
@FUNCTION=SIN
@SEEALSO=COS,TAN,CSC,SEC,SINH,COSH,TANH,RADIANS,DEGREES

@CATEGORY=Mathematics
@FUNCTION=SINH
@SEEALSO=ACOS,ASINH,DEGREES,RADIANS 

@CATEGORY=Mathematics
@FUNCTION=SQRT
@SYNTAX=SQRT(x)
@DESCRIPTION=.
@{x}: non-negative number
@NOTE=If @{x} is negative, SQRT returns #NUM!
@SEEALSO=POWER

@CATEGORY=Mathematics
@FUNCTION=SQRTPI
@SEEALSO=PI

@CATEGORY=Mathematics
@FUNCTION=SUM
@SYNTAX=SUM(values)
@DESCRIPTION=SUM computes the sum of all the values and cells referenced in the argument list.
@{values}: a list of values to add

@SEEALSO=AVERAGE,COUNT

@CATEGORY=Mathematics
@FUNCTION=SUMA
@SYNTAX=SUMA(area0,area1)
@DESCRIPTION=Numbers, text and logical values are included in the calculation too. If the cell contains text or the argument evaluates to FALSE, it is counted as value zero (0). If the argument evaluates to TRUE, it is counted as one (1).
@{area0}: first cell area
@{area1}: second cell area

@SEEALSO=AVERAGE,SUM,COUNT

@CATEGORY=Mathematics
@FUNCTION=SUMIF
@SEEALSO=SUM,COUNTIF

@CATEGORY=Mathematics
@FUNCTION=SUMPRODUCT
@SYNTAX=SUMPRODUCT()
@DESCRIPTION=Multiplies corresponding data entries in the given arrays or ranges, and then returns the sum of those products.

@NOTE=If an entry is not numeric, the value zero is used instead.
@NOTE=If arrays or range arguments do not have the same dimensions, return #VALUE! error.
@NOTE=SUMPRODUCTs arguments are arrays or ranges. Attempting to use A1:A5>0 will not work, implicit intersection will kick in. Instead use --(A1:A5>0)
@SEEALSO=SUM,PRODUCT,G_PRODUCT

@CATEGORY=Mathematics
@FUNCTION=SUMSQ
@SEEALSO=SUM,COUNT

@CATEGORY=Mathematics
@FUNCTION=SUMX2MY2
@SYNTAX=SUMX2MY2(array0,array1)
@DESCRIPTION=SUMX2MY2 function returns the sum of the difference of squares of corresponding values in two arrays. The equation of SUMX2MY2 is SUM(x^2-y^2).
@{array0}: first cell area
@{array1}: second cell area

@SEEALSO=SUMSQ,SUMX2PY2

@CATEGORY=Mathematics
@FUNCTION=SUMX2PY2
@SYNTAX=SUMX2PY2(array0,array1)
@DESCRIPTION=SUMX2PY2 function returns the sum of the sum of squares of corresponding values in two arrays. The equation of SUMX2PY2 is SUM(x^2+y^2).
@{array0}: first cell area
@{array1}: second cell area

@NOTE=If @{array0} and @{array1} have different number of data points, SUMX2PY2 returns #N/A.
Strings and empty cells are simply ignored.
@SEEALSO=SUMSQ,SUMX2MY2

@CATEGORY=Mathematics
@FUNCTION=SUMXMY2
@SYNTAX=SUMXMY2(array0,array1)
@DESCRIPTION=SUMXMY2 function returns the sum of the squares of the differences of corresponding values in two arrays. The equation of SUMXMY2 is SUM((x-y)^2).
@{array0}: first cell area
@{array1}: second cell area

@NOTE=If @{array0} and @{array1} have different number of data points, SUMXMY2 returns #N/A.
Strings and empty cells are simply ignored.
@SEEALSO=SUMSQ,SUMX2MY2,SUMX2PY2

@CATEGORY=Mathematics
@FUNCTION=TAN
@SEEALSO=TANH,COS,COSH,SIN,SINH,DEGREES,RADIANS

@CATEGORY=Mathematics
@FUNCTION=TANH
@SEEALSO=TAN, SIN, SINH, COS, COSH, DEGREES, RADIANS

@CATEGORY=Mathematics
@FUNCTION=TRUNC
@SYNTAX=TRUNC(x,x)
@DESCRIPTION=.
@{x}: number
@{x}: non-negative integer, defaults to 0
@NOTE=If @{d} is omitted or negative then it defaults to zero. If it is not an integer then it is truncated to an integer.
@SEEALSO=INT

@CATEGORY=Number Theory
@FUNCTION=ISPRIME
@SYNTAX=ISPRIME(n)
@DESCRIPTION=ISPRIME returns TRUE if @{n} is prime and FALSE otherwise.
@{n}: positive integer

@SEEALSO=NT_D, NT_SIGMA

@CATEGORY=Number Theory
@FUNCTION=ITHPRIME
@SYNTAX=ITHPRIME(i)
@DESCRIPTION=ITHPRIME finds the @{i}th prime.
@{i}: positive integer

@SEEALSO=NT_D,NT_SIGMA

@CATEGORY=Number Theory
@FUNCTION=NT_D
@SYNTAX=NT_D(n)
@DESCRIPTION=NT_D calculates the number of divisors of @{n}.
@{n}: positive integer

@SEEALSO=ITHPRIME,NT_PHI,NT_SIGMA

@CATEGORY=Number Theory
@FUNCTION=NT_MU
@SYNTAX=NT_MU(n)
@DESCRIPTION=NT_MU function (Möbius mu function) returns 0  if @{n} is divisible by the square of a prime. Otherwise, if @{n} has an odd  number of different prime factors, NT_MU returns -1, and if @{n} has an even number of different prime factors, it returns 1. If @{n} = 1, NT_MU returns 1.
@{n}: positive integer

@SEEALSO=ITHPRIME,NT_PHI,NT_SIGMA,NT_D

@CATEGORY=Number Theory
@FUNCTION=NT_PHI
@SYNTAX=NT_PHI(n)
@DESCRIPTION=.
@{n}: positive integer
@NOTE=Euler's totient function gives the number of integers less than or equal to @{n} that are relatively prime (coprime) to @{n}.
@SEEALSO=NT_D,ITHPRIME,NT_SIGMA

@CATEGORY=Number Theory
@FUNCTION=NT_PI
@SYNTAX=NT_PI(n)
@DESCRIPTION=NT_PI returns the number of primes less than or equal to @{n}.
@{n}: positive integer

@SEEALSO=ITHPRIME,NT_PHI,NT_D,NT_SIGMA

@CATEGORY=Number Theory
@FUNCTION=NT_SIGMA
@SYNTAX=NT_SIGMA(n)
@DESCRIPTION=NT_SIGMA calculates the sum of the divisors of @{n}.
@{n}: positive integer

@SEEALSO=NT_D,ITHPRIME,NT_PHI

@CATEGORY=Number Theory
@FUNCTION=PFACTOR
@SYNTAX=PFACTOR(n)
@DESCRIPTION=PFACTOR finds the smallest prime factor of its argument.
@{n}: positive integer

@NOTE=The argument @{n} must be at least 2. Otherwise a #VALUE! error is returned.
@SEEALSO=ITHPRIME

@CATEGORY=Random Numbers
@FUNCTION=RAND
@SEEALSO=RANDBETWEEN

@CATEGORY=Random Numbers
@FUNCTION=RANDBERNOULLI
@SYNTAX=RANDBERNOULLI(p)
@DESCRIPTION=.
@{p}: probability of success
@NOTE=If @{p} < 0 or @{p} > 1 RANDBERNOULLI returns #NUM!
@SEEALSO=RAND,RANDBETWEEN

@CATEGORY=Random Numbers
@FUNCTION=RANDBETA
@SEEALSO=RAND,RANDGAMMA

@CATEGORY=Random Numbers
@FUNCTION=RANDBETWEEN
@SYNTAX=RANDBETWEEN(bottom,top)
@DESCRIPTION=.
@{bottom}: lower limit
@{top}: upper limit
@NOTE=If @{bottom} > @{top}, RANDBETWEEN returns #NUM!
@SEEALSO=RAND,RANDUNIFORM

@CATEGORY=Random Numbers
@FUNCTION=RANDBINOM
@SYNTAX=RANDBINOM(p,n)
@DESCRIPTION=.
@{p}: probability of success in a single trial
@{n}: number of trials
@NOTE=If @{p} < 0 or @{p} > 1 RANDBINOM returns #NUM!
@NOTE=If @{n} < 0 RANDBINOM returns #NUM!
@SEEALSO=RAND,RANDBETWEEN

@CATEGORY=Random Numbers
@FUNCTION=RANDCAUCHY
@SYNTAX=RANDCAUCHY(a)
@DESCRIPTION=.
@{a}: scale parameter of the distribution
@NOTE=If @{a} < 0 RANDCAUCHY returns #NUM!
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDCHISQ
@SEEALSO=RAND,RANDGAMMA

@CATEGORY=Random Numbers
@FUNCTION=RANDDISCRETE
@SYNTAX=RANDDISCRETE(val_range,prob_range)
@DESCRIPTION=RANDDISCRETE returns one of the values in the @{val_range}. The probabilities for each value are given in the @{prob_range}.
@{val_range}: possible values of the random variable
@{prob_range}: probabilities of the corresponding values in @{val_range}, defaults to equal probabilities

@NOTE=If the sum of all values in @{prob_range} is not one, RANDDISCRETE returns #NUM!
@NOTE=If @{val_range} and @{prob_range} are not the same size, RANDDISCRETE returns #NUM!
@NOTE=If @{val_range} or @{prob_range} is not a range, RANDDISCRETE returns #VALUE!
@SEEALSO=RANDBETWEEN,RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDEXP
@SEEALSO=RAND,RANDBETWEEN

@CATEGORY=Random Numbers
@FUNCTION=RANDEXPPOW
@SYNTAX=RANDEXPPOW(a,b)
@DESCRIPTION=For @{b} = 1 the exponential power distribution reduces to the Laplace distribution.
@{a}: scale parameter of the exponential power distribution
@{b}: exponent of the exponential power distribution

@DESCRIPTION=For @{b} = 2 the exponential power distribution reduces to the normal distribution with σ = a/sqrt(2)
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDFDIST
@SEEALSO=RAND,RANDGAMMA

@CATEGORY=Random Numbers
@FUNCTION=RANDGAMMA
@SYNTAX=RANDGAMMA(a,b)
@DESCRIPTION=.
@{a}: parameter of the Gamma distribution
@{b}: parameter of the Gamma distribution
@NOTE=If @{a} ≤ 0, RANDGAMMA returns #NUM!
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDGEOM
@SYNTAX=RANDGEOM(p)
@DESCRIPTION=.
@{p}: probability of success in a single trial
@NOTE=If @{p} < 0 or @{p} > 1 RANDGEOM returns #NUM!
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDGUMBEL
@SYNTAX=RANDGUMBEL(a,b,type)
@DESCRIPTION=.
@{a}: parameter of the Gumbel distribution
@{b}: parameter of the Gumbel distribution
@{type}: type of the Gumbel distribution, defaults to 1
@NOTE=If @{type} is neither 1 nor 2, RANDGUMBEL returns #NUM!
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDHYPERG
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDLANDAU
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDLAPLACE
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDLEVY
@SYNTAX=RANDLEVY(c,α,β)
@DESCRIPTION=For @{α} = 1, @{β}=0, the Lévy distribution reduces to the Cauchy (or Lorentzian) distribution.
@{c}: parameter of the Lévy distribution
@{α}: parameter of the Lévy distribution
@{β}: parameter of the Lévy distribution, defaults to 0

@DESCRIPTION=For @{α} = 2, @{β}=0, the Lévy distribution reduces to the normal distribution.
@NOTE=If @{α} ≤ 0 or @{α} > 2, RANDLEVY returns #NUM!
@NOTE=If @{β} < -1 or @{β} > 1, RANDLEVY returns #NUM!
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDLOG
@SYNTAX=RANDLOG(p)
@DESCRIPTION=.
@{p}: probability
@NOTE=If @{p} < 0 or @{p} > 1 RANDLOG returns #NUM!
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDLOGISTIC
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDLOGNORM
@SYNTAX=RANDLOGNORM(ζ,σ)
@DESCRIPTION=.
@{ζ}: parameter of the lognormal distribution
@{σ}: standard deviation of the distribution
@NOTE=If @{σ} < 0, RANDLOGNORM returns #NUM!
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDNEGBINOM
@SYNTAX=RANDNEGBINOM(p,n)
@DESCRIPTION=.
@{p}: probability of success in a single trial
@{n}: number of failures
@NOTE=If @{p} < 0 or @{p} > 1 RANDNEGBINOM returns #NUM!
@NOTE=If @{n} < 1 RANDNEGBINOM returns #NUM!
@SEEALSO=RAND,RANDBETWEEN

@CATEGORY=Random Numbers
@FUNCTION=RANDNORM
@SYNTAX=RANDNORM(μ,σ)
@DESCRIPTION=.
@{μ}: mean of the distribution
@{σ}: standard deviation of the distribution
@NOTE=If @{σ} < 0, RANDNORM returns #NUM!
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDNORMTAIL
@SYNTAX=RANDNORMTAIL(a,σ)
@DESCRIPTION=.
@{a}: lower limit of the tail
@{σ}: standard deviation of the normal distribution
@NOTE=The method is based on Marsaglia's famous rectangle-wedge-tail algorithm (Ann Math Stat 32, 894-899 (1961)), with this aspect explained in Knuth, v2, 3rd ed, p139, 586 (exercise 11).
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDPARETO
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDPOISSON
@SYNTAX=RANDPOISSON(λ)
@DESCRIPTION=.
@{λ}: parameter of the Poisson distribution
@NOTE=If @{λ} < 0 RANDPOISSON returns #NUM!
@SEEALSO=RAND,RANDBETWEEN

@CATEGORY=Random Numbers
@FUNCTION=RANDRAYLEIGH
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDRAYLEIGHTAIL
@SEEALSO=RAND,RANDRAYLEIGH

@CATEGORY=Random Numbers
@FUNCTION=RANDSNORM
@SYNTAX=RANDSNORM(a,μ,σ)
@DESCRIPTION=.
@{a}:  amount of skew, defaults to 0
@{μ}: mean of the underlying normal distribution, defaults to 0
@{σ}: standard deviation of the underlying normal distribution, defaults to 1
@NOTE=If @{σ} < 0, RANDSNORM returns #NUM!
@SEEALSO=RANDNORM

@CATEGORY=Random Numbers
@FUNCTION=RANDSTDIST
@SEEALSO=RANDTDIST

@CATEGORY=Random Numbers
@FUNCTION=RANDTDIST
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDUNIFORM
@SYNTAX=RANDUNIFORM(a,b)
@DESCRIPTION=.
@{a}: lower limit of the uniform distribution
@{b}: upper limit of the uniform distribution
@NOTE=If @{a} > @{b} RANDUNIFORM returns #NUM!
@SEEALSO=RANDBETWEEN,RAND

@CATEGORY=Random Numbers
@FUNCTION=RANDWEIBULL
@SEEALSO=RAND

@CATEGORY=Random Numbers
@FUNCTION=SIMTABLE
@SYNTAX=SIMTABLE(d1,d2)
@DESCRIPTION=SIMTABLE returns one of the values in the given argument list depending on the round number of the simulation tool. When the simulation tool is not activated, SIMTABLE returns @{d1}.
With the simulation tool and the SIMTABLE function you can test given decision variables. Each SIMTABLE function contains the possible values of a simulation variable. In most valid simulation models you should have the same number of values @{dN} for all decision variables.  If the simulation is run more rounds than there are values defined, SIMTABLE returns #N/A! error (e.g. if A1 contains `=SIMTABLE(1)' and A2 `=SIMTABLE(1,2)', A1 yields #N/A! error on the second round).
The successive use of the simulation tool also requires that you give to the tool at least one input variable having RAND() or any other RAND<distribution name>() function in it. On each round, the simulation tool iterates for the given number of rounds over all the input variables to reevaluate them. On each iteration, the values of the output variables are stored, and when the round is completed, descriptive statistical information is created according to the values.
@{d1}: first value
@{d2}: second value


@CATEGORY=Statistics
@FUNCTION=AVEDEV
@SEEALSO=STDEV

@CATEGORY=Statistics
@FUNCTION=AVERAGE
@SEEALSO=SUM, COUNT

@CATEGORY=Statistics
@FUNCTION=AVERAGEA
@SYNTAX=AVERAGEA(number1,number2)
@DESCRIPTION=Numbers, text and logical values are included in the calculation too. If the cell contains text or the argument evaluates to FALSE, it is counted as value zero (0). If the argument evaluates to TRUE, it is counted as one (1). Note that empty cells are not counted.
@{number1}: first value
@{number2}: second value

@SEEALSO=AVERAGE

@CATEGORY=Statistics
@FUNCTION=BERNOULLI
@SYNTAX=BERNOULLI(k,p)
@DESCRIPTION=.
@{k}: 
@{p}: probability of success
@NOTE=If @{k} != 0 and @{k} != 1 this function returns a #NUM! error.
@NOTE=If @{p} < 0 or @{p} > 1 this function returns a #NUM! error.
@SEEALSO=RANDBERNOULLI

@CATEGORY=Statistics
@FUNCTION=BETADIST
@SYNTAX=BETADIST(x,alpha,beta,a,b)
@DESCRIPTION=.
@{x}: 
@{alpha}: scale parameter
@{beta}: scale parameter
@{a}: optional lower bound, defaults to 0
@{b}: optional upper bound, defaults to 1
@NOTE=If @{x} < @{a} or @{x} > @{b} this function returns a #NUM! error.
@NOTE=If @{alpha} <= 0 or @{beta} <= 0, this function returns a #NUM! error.
@NOTE=If @{a} >= @{b} this function returns a #NUM! error.
@SEEALSO=BETAINV

@CATEGORY=Statistics
@FUNCTION=BETAINV
@SYNTAX=BETAINV(p,alpha,beta,a,b)
@DESCRIPTION=.
@{p}: probability
@{alpha}: scale parameter
@{beta}: scale parameter
@{a}: optional lower bound, defaults to 0
@{b}: optional upper bound, defaults to 1
@NOTE=If @{p} < 0 or @{p} > 1 this function returns a #NUM! error.
@NOTE=If @{alpha} <= 0 or @{beta} <= 0, this function returns a #NUM! error.
@NOTE=If @{a} >= @{b} this function returns a #NUM! error.
@SEEALSO=BETADIST

@CATEGORY=Statistics
@FUNCTION=BINOM.DIST.RANGE
@SYNTAX=BINOM.DIST.RANGE(trials,p,start,end)
@DESCRIPTION=.
@{trials}: number of trials
@{p}: probability of success in each trial
@{start}: start of the interval
@{end}: start of the interval, defaults to @{start}
@NOTE=If @{start}, @{end} or @{trials} are non-integer they are truncated.
@NOTE=If @{trials} < 0 this function returns a #NUM! error.
@NOTE=If @{p} < 0 or @{p} > 1 this function returns a #NUM! error.
@NOTE=If @{start} > @{end} this function returns 0.
@SEEALSO=BINOMDIST,R.PBINOM

@CATEGORY=Statistics
@FUNCTION=BINOMDIST
@SYNTAX=BINOMDIST(n,trials,p,cumulative)
@DESCRIPTION=.
@{n}: number of successes
@{trials}: number of trials
@{p}: probability of success in each trial
@{cumulative}: whether to evaluate the mass function or the cumulative distribution function
@NOTE=If @{n} or @{trials} are non-integer they are truncated.
@NOTE=If @{n} < 0 or @{trials} < 0 this function returns a #NUM! error.
@NOTE=If @{n} > @{trials} this function returns a #NUM! error.
@NOTE=If @{p} < 0 or @{p} > 1 this function returns a #NUM! error.
@SEEALSO=POISSON

@CATEGORY=Statistics
@FUNCTION=CAUCHY
@SYNTAX=CAUCHY(x,a,cumulative)
@DESCRIPTION=.
@{x}: 
@{a}: scale parameter
@{cumulative}: whether to evaluate the density function or the cumulative distribution function
@NOTE=If @{a} < 0 this function returns a #NUM! error.
@NOTE=If @{cumulative} is neither TRUE nor FALSE this function returns a #VALUE! error.
@SEEALSO=RANDCAUCHY

@CATEGORY=Statistics
@FUNCTION=CHIDIST
@SYNTAX=CHIDIST(x,dof)
@DESCRIPTION=The survival function is 1 minus the cumulative distribution function.
@{x}: 
@{dof}: number of degrees of freedom

@NOTE=If @{dof} is non-integer it is truncated.
@NOTE=If @{dof} < 1 this function returns a #NUM! error.
@SEEALSO=CHIINV,CHITEST

@CATEGORY=Statistics
@FUNCTION=CHIINV
@SYNTAX=CHIINV(p,dof)
@DESCRIPTION=The survival function is 1 minus the cumulative distribution function.
@{p}: probability
@{dof}: number of degrees of freedom

@NOTE=If @{p} < 0 or @{p} > 1 or @{dof} < 1 this function returns a #NUM! error.
@SEEALSO=CHIDIST,CHITEST

@CATEGORY=Statistics
@FUNCTION=CHITEST
@SYNTAX=CHITEST(actual_range,theoretical_range)
@DESCRIPTION=.
@{actual_range}: observed data
@{theoretical_range}: expected values
@NOTE=If the actual range is not an n by 1 or 1 by n range, the returned value appears to have no sensible meaning.
@SEEALSO=CHIDIST,CHIINV

@CATEGORY=Statistics
@FUNCTION=CONFIDENCE
@SYNTAX=CONFIDENCE(alpha,stddev,size)
@DESCRIPTION=.
@{alpha}: significance level
@{stddev}: population standard deviation
@{size}: sample size
@NOTE=This function requires the usually unknown population standard deviation.
@NOTE=If @{size} is non-integer it is truncated.
@NOTE=If @{size} < 0 this function returns a #NUM! error.
@NOTE=If @{size} is 0 this function returns a #DIV/0! error.
@SEEALSO=AVERAGE

@CATEGORY=Statistics
@FUNCTION=CORREL
@SYNTAX=CORREL(array1,array2)
@DESCRIPTION=Strings and empty cells are simply ignored.
@{array1}: first data set
@{array2}: second data set

@SEEALSO=COVAR,FISHER,FISHERINV

@CATEGORY=Statistics
@FUNCTION=COUNT
@SEEALSO=AVERAGE

@CATEGORY=Statistics
@FUNCTION=COUNTA
@SEEALSO=AVERAGE,COUNT,DCOUNT,DCOUNTA,PRODUCT,SUM

@CATEGORY=Statistics
@FUNCTION=COVAR
@SYNTAX=COVAR(array1,array2)
@DESCRIPTION=Strings and empty cells are simply ignored.
@{array1}: first data set
@{array2}: set data set

@SEEALSO=CORREL,FISHER,FISHERINV

@CATEGORY=Statistics
@FUNCTION=CRITBINOM
@SYNTAX=CRITBINOM(trials,p,alpha)
@DESCRIPTION=.
@{trials}: number of trials
@{p}: probability of success in each trial
@{alpha}: significance level (area of the tail)
@NOTE=If @{trials} is a non-integer it is truncated.
@NOTE=If @{trials} < 0 this function returns a #NUM! error.
@NOTE=If @{p} < 0 or @{p} > 1 this function returns a #NUM! error.
@NOTE=If @{alpha} < 0 or @{alpha} > 1 this function returns a #NUM! error.
@SEEALSO=BINOMDIST

@CATEGORY=Statistics
@FUNCTION=CRONBACH
@SEEALSO=VAR

@CATEGORY=Statistics
@FUNCTION=DEVSQ
@SYNTAX=DEVSQ(number1,number2)
@DESCRIPTION=Strings and empty cells are simply ignored.
@{number1}: first value
@{number2}: second value

@SEEALSO=STDEV

@CATEGORY=Statistics
@FUNCTION=EXPONDIST
@SYNTAX=EXPONDIST(x,y,cumulative)
@DESCRIPTION=If @{cumulative} is false it will return:	@{y} * exp (-@{y}*@{x}),otherwise it will return	1 - exp (-@{y}*@{x}).
@{x}: 
@{y}: scale parameter
@{cumulative}: whether to evaluate the density function or the cumulative distribution function

@NOTE=If @{x} < 0 or @{y} <= 0 this will return an error.
@SEEALSO=POISSON

@CATEGORY=Statistics
@FUNCTION=EXPPOWDIST
@SYNTAX=EXPPOWDIST(x,a,b)
@DESCRIPTION=This distribution has been recommended for lifetime analysis when a U-shaped hazard function is desired. This corresponds to rapid failure once the product starts to wear out after a period of steady or even improving reliability.
@{x}: 
@{a}: scale parameter
@{b}: scale parameter

@SEEALSO=RANDEXPPOW

@CATEGORY=Statistics
@FUNCTION=FDIST
@SYNTAX=FDIST(x,dof_of_num,dof_of_denom)
@DESCRIPTION=The survival function is 1 minus the cumulative distribution function.
@{x}: 
@{dof_of_num}: numerator degrees of freedom
@{dof_of_denom}: denominator degrees of freedom

@NOTE=If @{x} < 0 this function returns a #NUM! error.
@NOTE=If @{dof_of_num} < 1 or @{dof_of_denom} < 1, this function returns a #NUM! error.
@SEEALSO=FINV

@CATEGORY=Statistics
@FUNCTION=FINV
@SYNTAX=FINV(p,dof_of_num,dof_of_denom)
@DESCRIPTION=The survival function is 1 minus the cumulative distribution function.
@{p}: probability
@{dof_of_num}: numerator degrees of freedom
@{dof_of_denom}: denominator degrees of freedom

@NOTE=If @{p} < 0 or @{p} > 1 this function returns a #NUM! error.
@NOTE=If @{dof_of_num} < 1 or @{dof_of_denom} < 1 this function returns a #NUM! error.
@SEEALSO=FDIST

@CATEGORY=Statistics
@FUNCTION=FISHER
@SYNTAX=FISHER(x)
@DESCRIPTION=.
@{x}: 
@NOTE=If @{x} is not a number, this function returns a #VALUE! error.
@NOTE=If @{x} <= -1 or @{x} >= 1, this function returns a #NUM! error.
@SEEALSO=FISHERINV,ATANH

@CATEGORY=Statistics
@FUNCTION=FISHERINV
@SYNTAX=FISHERINV(x)
@DESCRIPTION=.
@{x}: 
@NOTE=If @{x} is a non-number this function returns a #VALUE! error.
@SEEALSO=FISHER,TANH

@CATEGORY=Statistics
@FUNCTION=FORECAST
@SYNTAX=FORECAST(x,known_y's,known_x's)
@DESCRIPTION=This function estimates a future value according to existing values using simple linear regression.
@{x}: x-value whose matching y-value should be forecast
@{known_y's}: known y-values
@{known_x's}: known x-values

@NOTE=If @{known_x} or @{known_y} contains no data entries or different number of data entries, this function returns a #N/A error.
@NOTE=If the variance of the @{known_x} is zero, this function returns a #DIV/0 error.
@SEEALSO=INTERCEPT,TREND

@CATEGORY=Statistics
@FUNCTION=FREQUENCY
@SYNTAX=FREQUENCY(data_array,bins_array)
@DESCRIPTION=The results are given as an array.
@{data_array}: data values
@{bins_array}: array of cutoff values

@DESCRIPTION=If the @{bin_array} is empty, this function returns the number of data points in @{data_array}.

@CATEGORY=Statistics
@FUNCTION=FTEST
@SEEALSO=FDIST,FINV

@CATEGORY=Statistics
@FUNCTION=GAMMADIST
@SYNTAX=GAMMADIST(x,alpha,beta,cumulative)
@DESCRIPTION=.
@{x}: 
@{alpha}: scale parameter
@{beta}: scale parameter
@{cumulative}: whether to evaluate the density function or the cumulative distribution function
@NOTE=If @{x} < 0 this function returns a #NUM! error.
@NOTE=If @{alpha} <= 0 or @{beta} <= 0, this function returns a #NUM! error.
@SEEALSO=GAMMAINV

@CATEGORY=Statistics
@FUNCTION=GAMMAINV
@SYNTAX=GAMMAINV(p,alpha,beta)
@DESCRIPTION=.
@{p}: probability
@{alpha}: scale parameter
@{beta}: scale parameter
@NOTE=If @{p} < 0 or @{p} > 1 this function returns a #NUM! error.
@NOTE=If @{alpha} <= 0 or @{beta} <= 0 this function returns a #NUM! error.
@SEEALSO=GAMMADIST

@CATEGORY=Statistics
@FUNCTION=GEOMDIST
@SYNTAX=GEOMDIST(k,p,cumulative)
@DESCRIPTION=.
@{k}: number of trials
@{p}: probability of success in any trial
@{cumulative}: whether to evaluate the mass function or the cumulative distribution function
@NOTE=If @{k} < 0 this function returns a #NUM! error.
@NOTE=If @{p} < 0 or @{p} > 1 this function returns a #NUM! error.
@NOTE=If @{cumulative} is neither TRUE nor FALSE this function returns a #VALUE! error.
@SEEALSO=RANDGEOM

@CATEGORY=Statistics
@FUNCTION=GEOMEAN
@SYNTAX=GEOMEAN(number1,number2)
@DESCRIPTION=The geometric mean is equal to the Nth root of the product of the N values.
@{number1}: first value
@{number2}: second value

@SEEALSO=AVERAGE,HARMEAN,MEDIAN,MODE,TRIMMEAN

@CATEGORY=Statistics
@FUNCTION=GROWTH
@SYNTAX=GROWTH(known_y's,known_x's,new_x's,const)
@DESCRIPTION=GROWTH function applies the ``least squares'' method to fit an exponential curve to your data and predicts the exponential growth by using this curve.
@{known_y's}: known y-values
@{known_x's}: known x-values; if @{known_x}'s is omitted, an array {1, 2, 3, ...} is used.
@{new_x's}: x-values for which you want to estimate the y-values; defaults to @{known_x}'s
@{const}: if this is false the line will be forced to go through the origin; defaults to TRUE

@DESCRIPTION=GROWTH returns an array having one column and a row for each data point in @{new_x}.
@NOTE=If @{known_y}'s and @{known_x}'s have unequal number of data points, this function returns a #NUM! error.
@SEEALSO=LOGEST,GROWTH,TREND

@CATEGORY=Statistics
@FUNCTION=HARMEAN
@SYNTAX=HARMEAN(number1,number2)
@DESCRIPTION=The harmonic mean of N data points is  N divided by the sum of the reciprocals of the data points).
@{number1}: first value
@{number2}: second value

@SEEALSO=AVERAGE,GEOMEAN,MEDIAN,MODE,TRIMMEAN

@CATEGORY=Statistics
@FUNCTION=HYPGEOMDIST
@SYNTAX=HYPGEOMDIST(x,n,M,N,cumulative)
@DESCRIPTION=.
@{x}: number of successes
@{n}: sample size
@{M}: number of possible successes in the population
@{N}: population size
@{cumulative}: whether to evaluate the mass function or the cumulative distribution function
@NOTE=If @{x},@{n},@{M} or @{N} is a non-integer it is truncated.
@NOTE=If @{x},@{n},@{M} or @{N} < 0 this function returns a #NUM! error.
@NOTE=If @{x} > @{M} or @{n} > @{N} this function returns a #NUM! error.
@SEEALSO=BINOMDIST,POISSON

@CATEGORY=Statistics
@FUNCTION=INTERCEPT
@SYNTAX=INTERCEPT(known_y's,known_x's)
@DESCRIPTION=.
@{known_y's}: known y-values
@{known_x's}: known x-values
@NOTE=If @{known_x} or @{known_y} contains no data entries or different number of data entries, this function returns a #N/A error.
@NOTE=If the variance of the @{known_x} is zero, this function returns #DIV/0 error.
@SEEALSO=FORECAST,TREND

@CATEGORY=Statistics
@FUNCTION=KURT
@SYNTAX=KURT(number1,number2)
@DESCRIPTION=Strings and empty cells are simply ignored.
@{number1}: first value
@{number2}: second value

@NOTE=This is only meaningful if the underlying distribution really has a fourth moment.  The kurtosis is offset by three such that a normal distribution will have zero kurtosis.
@NOTE=If fewer than four numbers are given or all of them are equal this function returns a #DIV/0! error.
@SEEALSO=AVERAGE,VAR,SKEW,KURTP

@CATEGORY=Statistics
@FUNCTION=KURTP
@SYNTAX=KURTP(number1,number2)
@DESCRIPTION=Strings and empty cells are simply ignored.
@{number1}: first value
@{number2}: second value

@NOTE=If fewer than two numbers are given or all of them are equal this function returns a #DIV/0! error.
@SEEALSO=AVERAGE,VARP,SKEWP,KURT

@CATEGORY=Statistics
@FUNCTION=LANDAU
@SEEALSO=RANDLANDAU

@CATEGORY=Statistics
@FUNCTION=LAPLACE
@SEEALSO=RANDLAPLACE

@CATEGORY=Statistics
@FUNCTION=LARGE
@SYNTAX=LARGE(data,k)
@DESCRIPTION=.
@{data}: data set
@{k}: which value to find
@NOTE=If data set is empty this function returns a #NUM! error.
@NOTE=If @{k} <= 0 or @{k} is greater than the number of data items given this function returns a #NUM! error.
@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,SMALL

@CATEGORY=Statistics
@FUNCTION=LINEST
@SYNTAX=LINEST(known_y's,known_x's,affine,stats)
@DESCRIPTION=This function returns an array with the first row giving the regression coefficients for the independent variables x_m, x_(m-1),...,x_2, x_1 followed by the y-intercept if @{affine} is true.
@{known_y's}: vector of values of dependent variable.
@{known_x's}: array of values of independent variables, defaults to a single vector 1,...,n.
@{affine}: if true, the model contains a constant term, defaults to true.
@{stats}: if true, some additional statistics are provided, defaults to false

@DESCRIPTION=If @{stats} is true, the second row contains the corresponding standard errors of the regression coefficients.In this case, the third row contains the R^2 value and the standard error for the predicted value. The fourth row contains the observed F value and its degrees of freedom. Finally, the fifth row contains the regression sum of squares and the residual sum of squares.
@DESCRIPTION=If @{affine} is false, R^2 is the uncentered version of the coefficient of determination; that is the proportion of the sum of squares explained by the model.
@NOTE=If the length of @{known_y's} does not match the corresponding length of @{known_x's}, this function returns a #NUM! error.
@SEEALSO=LOGEST,TREND

@CATEGORY=Statistics
@FUNCTION=LOGEST
@SYNTAX=LOGEST(known_y's,known_x's,const,stat)
@DESCRIPTION=LOGEST function applies the ``least squares'' method to fit an exponential curve of the form	y = b * m{1}^x{1} * m{2}^x{2}... to your data.
@{known_y's}: known y-values
@{known_x's}: known x-values; if @{known_x}'s is omitted, an array {1, 2, 3, ...} is used.
@{const}: if this is false the line will be forced to go through (0,1); defaults to TRUE
@{stat}: If @{stat} is TRUE, extra statistical information will be returned; defaults to FALSE.

@DESCRIPTION=LOGEST returns an array { m{n},m{n-1}, ...,m{1},b }.
@NOTE=Extra statistical information is written below the regression line coefficients in the result array.  Extra statistical information consists of four rows of data.  In the first row the standard error values for the coefficients m1, (m2, ...), b are represented.  The second row contains the square of R and the standard error for the y estimate.  The third row contains the F-observed value and the degrees of freedom.  The last row contains the regression sum of squares and the residual sum of squares.
@NOTE=If @{known_y}'s and @{known_x}'s have unequal number of data points, this function returns a #NUM! error.
@SEEALSO=GROWTH,TREND

@CATEGORY=Statistics
@FUNCTION=LOGFIT
@SYNTAX=LOGFIT(known_y's,known_x's)
@DESCRIPTION=LOGFIT function applies the ``least squares'' method to fit the logarithmic equation y = a + b * ln(sign * (x - c)) ,   sign = +1 or -1 to your data. The graph of the equation is a logarithmic curve moved horizontally by c and possibly mirrored across the y-axis (if sign = -1).
@{known_y's}: known y-values
@{known_x's}: known x-values

@DESCRIPTION=LOGFIT returns an array having five columns and one row. `Sign' is given in the first column, `a', `b', and `c' are given in columns 2 to 4. Column 5 holds the sum of squared residuals.
@NOTE=An error is returned when there are less than 3 different x's or y's, or when the shape of the point cloud is too different from a ``logarithmic'' one.
@NOTE=You can use the above formula = a + b * ln(sign * (x - c)) or rearrange it to = (exp((y - a) / b)) / sign + c to compute unknown y's or x's, respectively. 
@NOTE=This is non-linear fitting by trial-and-error. The accuracy of `c' is: width of x-range -> rounded to the next smaller (10^integer), times 0.000001. There might be cases in which the returned fit is not the best possible.
@SEEALSO=LOGREG,LINEST,LOGEST

@CATEGORY=Statistics
@FUNCTION=LOGINV
@SYNTAX=LOGINV(p,mean,stddev)
@DESCRIPTION=.
@{p}: probability
@{mean}: mean
@{stddev}: standard deviation
@NOTE=If @{p} < 0 or @{p} > 1 or @{stddev} <= 0 this function returns #NUM! error.
@SEEALSO=EXP,LN,LOG,LOG10,LOGNORMDIST

@CATEGORY=Statistics
@FUNCTION=LOGISTIC
@SEEALSO=RANDLOGISTIC

@CATEGORY=Statistics
@FUNCTION=LOGNORMDIST
@SYNTAX=LOGNORMDIST(x,mean,stddev)
@DESCRIPTION=.
@{x}: 
@{mean}: mean
@{stddev}: standard deviation
@NOTE=If @{stddev} = 0 LOGNORMDIST returns a #DIV/0! error.
@NOTE=If @{x} <= 0, @{mean} < 0 or @{stddev} <= 0 this function returns a #NUM! error.
@SEEALSO=NORMDIST

@CATEGORY=Statistics
@FUNCTION=LOGREG
@SYNTAX=LOGREG(known_y's,known_x's,const,stat)
@DESCRIPTION=LOGREG function transforms your x's to z=ln(x) and applies the ``least squares'' method to fit the linear equation y = m * z + b to your y's and z's --- equivalent to fitting the equation y = m * ln(x) + b to y's and x's. LOGREG returns an array having two columns and one row. m is given in the first column and b in the second. 
@{known_y's}: known y-values
@{known_x's}: known x-values; if @{known_x}'s is omitted, an array {1, 2, 3, ...} is used.
@{const}: If this is FALSE, the curve will be forced to go through [1; 0], i.e., b will be zero. The default is TRUE.
@{stat}: If @{stat} is TRUE, extra statistical information will be returned; defaults to FALSE.

@DESCRIPTION=Any extra statistical information is written below m and b in the result array.  This extra statistical information consists of four rows of data:  In the first row the standard error values for the coefficients m, b are given.  The second row contains the square of R and the standard error for the y estimate. The third row contains the F-observed value and the degrees of freedom.  The last row contains the regression sum of squares and the residual sum of squares.The default of @{stat} is FALSE.
@NOTE=If @{known_y}'s and @{known_x}'s have unequal number of data points, this function returns a #NUM! error.
@SEEALSO=LOGFIT,LINEST,LOGEST

@CATEGORY=Statistics
@FUNCTION=MAX
@SEEALSO=MIN,ABS

@CATEGORY=Statistics
@FUNCTION=MAXA
@SYNTAX=MAXA(number1,number2)
@DESCRIPTION=Numbers, text and logical values are included in the calculation too. If the cell contains text or the argument evaluates to FALSE, it is counted as value zero (0). If the argument evaluates to TRUE, it is counted as one (1). Note that empty cells are not counted.
@{number1}: first value
@{number2}: second value

@SEEALSO=MAX,MINA

@CATEGORY=Statistics
@FUNCTION=MEDIAN
@SYNTAX=MEDIAN(number1,number2)
@DESCRIPTION=Strings and empty cells are simply ignored.
@{number1}: first value
@{number2}: second value

@NOTE=If even numbers are given MEDIAN returns the average of the two numbers in the center.
@SEEALSO=AVERAGE,COUNT,COUNTA,DAVERAGE,MODE,SSMEDIAN,SUM

@CATEGORY=Statistics
@FUNCTION=MIN
@SEEALSO=MAX,ABS

@CATEGORY=Statistics
@FUNCTION=MINA
@SYNTAX=MINA(number1,number2)
@DESCRIPTION=Numbers, text and logical values are included in the calculation too. If the cell contains text or the argument evaluates to FALSE, it is counted as value zero (0). If the argument evaluates to TRUE, it is counted as one (1). Note that empty cells are not counted.
@{number1}: first value
@{number2}: second value

@SEEALSO=MIN,MAXA

@CATEGORY=Statistics
@FUNCTION=MODE
@SYNTAX=MODE(number1,number2)
@DESCRIPTION=Strings and empty cells are simply ignored.
@{number1}: first value
@{number2}: second value

@DESCRIPTION=If the data set does not contain any duplicates this function returns a #N/A error.
@SEEALSO=AVERAGE,MEDIAN

@CATEGORY=Statistics
@FUNCTION=NEGBINOMDIST
@SYNTAX=NEGBINOMDIST(f,t,p)
@DESCRIPTION=.
@{f}: number of failures
@{t}: threshold number of successes
@{p}: probability of a success
@NOTE=If @{f} or @{t} is a non-integer it is truncated.
@NOTE=If (@{f} + @{t} -1) <= 0 this function returns a #NUM! error.
@NOTE=If @{p} < 0 or @{p} > 1 this functions returns a #NUM! error.
@SEEALSO=BINOMDIST,COMBIN,FACT,HYPGEOMDIST,PERMUT

@CATEGORY=Statistics
@FUNCTION=NORMDIST
@SYNTAX=NORMDIST(x,mean,stddev,cumulative)
@DESCRIPTION=.
@{x}: 
@{mean}: mean of the distribution
@{stddev}: standard deviation of the distribution
@{cumulative}: whether to evaluate the density function or the cumulative distribution function
@NOTE=If @{stddev} is 0 this function returns a #DIV/0! error.
@SEEALSO=POISSON

@CATEGORY=Statistics
@FUNCTION=NORMINV
@SYNTAX=NORMINV(p,mean,stddev)
@DESCRIPTION=.
@{p}: probability
@{mean}: mean of the distribution
@{stddev}: standard deviation of the distribution
@NOTE=If @{p} < 0 or @{p} > 1 or @{stddev} <= 0 this function returns a #NUM! error.
@SEEALSO=NORMDIST,NORMSDIST,NORMSINV,STANDARDIZE,ZTEST

@CATEGORY=Statistics
@FUNCTION=NORMSDIST
@SEEALSO=NORMDIST

@CATEGORY=Statistics
@FUNCTION=NORMSINV
@SYNTAX=NORMSINV(p)
@DESCRIPTION=.
@{p}: given probability
@NOTE=If @{p} < 0 or @{p} > 1 this function returns #NUM! error.
@SEEALSO=NORMDIST,NORMINV,NORMSDIST,STANDARDIZE,ZTEST

@CATEGORY=Statistics
@FUNCTION=PARETO
@SEEALSO=RANDPARETO

@CATEGORY=Statistics
@FUNCTION=PEARSON
@SYNTAX=PEARSON(array1,array2)
@DESCRIPTION=Strings and empty cells are simply ignored.
@{array1}: first component values
@{array2}: second component values

@SEEALSO=INTERCEPT,LINEST,RSQ,SLOPE,STEYX

@CATEGORY=Statistics
@FUNCTION=PERCENTILE
@SYNTAX=PERCENTILE(array,k)
@DESCRIPTION=.
@{array}: data points
@{k}: which percentile to calculate
@NOTE=If @{array} is empty, this function returns a #NUM! error.
@NOTE=If @{k} < 0 or @{k} > 1, this function returns a #NUM! error.
@SEEALSO=QUARTILE

@CATEGORY=Statistics
@FUNCTION=PERCENTRANK
@SYNTAX=PERCENTRANK(array,x,significance)
@DESCRIPTION=.
@{array}: range of numeric values
@{x}: data point to be ranked
@{significance}: number of significant digits, defaults to 3
@NOTE=If @{array} contains no data points, this function returns a #NUM! error.
@NOTE=If @{significance} is less than one, this function returns a #NUM! error.
@NOTE=If @{x} exceeds the largest value or is less than the smallest value in @{array}, this function returns a #NUM! error.
@NOTE=If @{x} does not match any of the values in @{array} or @{x} matches more than once, this function interpolates the returned value.
@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,QUARTILE,SMALL

@CATEGORY=Statistics
@FUNCTION=PERMUT
@SYNTAX=PERMUT(n,k)
@DESCRIPTION=.
@{n}: size of the base set
@{k}: number of elements in each permutation
@NOTE=If @{n} = 0 this function returns a #NUM! error.
@NOTE=If @{n} < @{k} this function returns a #NUM! error.
@SEEALSO=COMBIN

@CATEGORY=Statistics
@FUNCTION=PERMUTATIONA
@SYNTAX=PERMUTATIONA(x,y)
@DESCRIPTION=.
@{x}: total number of objects
@{y}: number of selected objects
@NOTE=If both @{x} and @{y} equal 0, PERMUTATIONA returns 1.
@NOTE=If @{x} < 0 or @{y} < 0, PERMUTATIONA returns #NUM!
@NOTE=If @{x} or @{y} are not integers, they are truncated
@SEEALSO=POWER

@CATEGORY=Statistics
@FUNCTION=POISSON
@SYNTAX=POISSON(x,mean,cumulative)
@DESCRIPTION=.
@{x}: number of events
@{mean}: mean of the distribution
@{cumulative}: whether to evaluate the mass function or the cumulative distribution function
@NOTE=If @{x} is a non-integer it is truncated.
@NOTE=If @{x} < 0 this function returns a #NUM! error.
@NOTE=If @{mean} <= 0 POISSON returns the #NUM! error.
@SEEALSO=NORMDIST,WEIBULL

@CATEGORY=Statistics
@FUNCTION=PROB
@SYNTAX=PROB(x_range,prob_range,lower_limit,upper_limit)
@DESCRIPTION=.
@{x_range}: possible values
@{prob_range}: probabilities of the corresponding values
@{lower_limit}: lower interval limit
@{upper_limit}: upper interval limit, defaults to @{lower_limit}
@NOTE=If the sum of the probabilities in @{prob_range} is not equal to 1 this function returns a #NUM! error.
@NOTE=If any value in @{prob_range} is <=0 or > 1, this function returns a #NUM! error.
@NOTE=If @{x_range} and @{prob_range} contain a different number of data entries, this function returns a #N/A error.
@SEEALSO=BINOMDIST,CRITBINOM

@CATEGORY=Statistics
@FUNCTION=QUARTILE
@SYNTAX=QUARTILE(array,quart)
@DESCRIPTION=.
@{array}: data points
@{quart}: A number from 0 to 4, indicating which quartile to calculate. A value of 0 causes the smallest value of @{array} to be returned.
@NOTE=If @{array} is empty, this function returns a #NUM! error.
@NOTE=If @{quart} < 0 or @{quart} > 4, this function returns a #NUM! error.
@NOTE=If @{quart} is not an integer, it is truncated.
@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,SMALL

@CATEGORY=Statistics
@FUNCTION=R.DBETA
@SYNTAX=R.DBETA(x,a,b,give_log)
@DESCRIPTION=This function returns the probability density function of the beta distribution.
@{x}: observation
@{a}: the first shape parameter of the distribution
@{b}: the second scale parameter of the distribution
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PBETA,R.QBETA

@CATEGORY=Statistics
@FUNCTION=R.DBINOM
@SYNTAX=R.DBINOM(x,n,psuc,give_log)
@DESCRIPTION=This function returns the probability density function of the binomial distribution.
@{x}: observation
@{n}: the number of trials
@{psuc}: the probability of success in each trial
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PBINOM,R.QBINOM

@CATEGORY=Statistics
@FUNCTION=R.DCAUCHY
@SYNTAX=R.DCAUCHY(x,location,scale,give_log)
@DESCRIPTION=This function returns the probability density function of the Cauchy distribution.
@{x}: observation
@{location}: the center of the distribution
@{scale}: the scale parameter of the distribution
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PCAUCHY,R.QCAUCHY

@CATEGORY=Statistics
@FUNCTION=R.DCHISQ
@SYNTAX=R.DCHISQ(x,df,give_log)
@DESCRIPTION=This function returns the probability density function of the chi-square distribution.
@{x}: observation
@{df}: the number of degrees of freedom of the distribution
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PCHISQ,R.QCHISQ

@CATEGORY=Statistics
@FUNCTION=R.DEXP
@SYNTAX=R.DEXP(x,scale,give_log)
@DESCRIPTION=This function returns the probability density function of the exponential distribution.
@{x}: observation
@{scale}: the scale parameter of the distribution
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PEXP,R.QEXP

@CATEGORY=Statistics
@FUNCTION=R.DF
@SYNTAX=R.DF(x,n1,n2,give_log)
@DESCRIPTION=This function returns the probability density function of the F distribution.
@{x}: observation
@{n1}: the first number of degrees of freedom of the distribution
@{n2}: the second number of degrees of freedom of the distribution
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PF,R.QF

@CATEGORY=Statistics
@FUNCTION=R.DGAMMA
@SYNTAX=R.DGAMMA(x,shape,scale,give_log)
@DESCRIPTION=This function returns the probability density function of the gamma distribution.
@{x}: observation
@{shape}: the shape parameter of the distribution
@{scale}: the scale parameter of the distribution
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PGAMMA,R.QGAMMA

@CATEGORY=Statistics
@FUNCTION=R.DGEOM
@SYNTAX=R.DGEOM(x,psuc,give_log)
@DESCRIPTION=This function returns the probability density function of the geometric distribution.
@{x}: observation
@{psuc}: the probability of success in each trial
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PGEOM,R.QGEOM

@CATEGORY=Statistics
@FUNCTION=R.DHYPER
@SYNTAX=R.DHYPER(x,r,b,n,give_log)
@DESCRIPTION=This function returns the probability density function of the hypergeometric distribution.
@{x}: observation
@{r}: the number of red balls
@{b}: the number of black balls
@{n}: the number of balls drawn
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PHYPER,R.QHYPER

@CATEGORY=Statistics
@FUNCTION=R.DLNORM
@SYNTAX=R.DLNORM(x,logmean,logsd,give_log)
@DESCRIPTION=This function returns the probability density function of the log-normal distribution.
@{x}: observation
@{logmean}: mean of the underlying normal distribution
@{logsd}: standard deviation of the underlying normal distribution
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PLNORM,R.QLNORM

@CATEGORY=Statistics
@FUNCTION=R.DNBINOM
@SYNTAX=R.DNBINOM(x,n,psuc,give_log)
@DESCRIPTION=This function returns the probability density function of the negative binomial distribution.
@{x}: observation
@{n}: the number of trials
@{psuc}: the probability of success in each trial
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PNBINOM,R.QNBINOM

@CATEGORY=Statistics
@FUNCTION=R.DNORM
@SYNTAX=R.DNORM(x,mu,sigma,give_log)
@DESCRIPTION=This function returns the probability density function of the normal distribution.
@{x}: observation
@{mu}: mean of the distribution
@{sigma}: standard deviation of the distribution
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PNORM,R.QNORM

@CATEGORY=Statistics
@FUNCTION=R.DPOIS
@SYNTAX=R.DPOIS(x,lambda,give_log)
@DESCRIPTION=This function returns the probability density function of the Poisson distribution.
@{x}: observation
@{lambda}: the mean of the distribution
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PPOIS,R.QPOIS

@CATEGORY=Statistics
@FUNCTION=R.DSNORM
@SYNTAX=R.DSNORM(x,shape,location,scale,give_log)
@DESCRIPTION=This function returns the probability density function of the skew-normal distribution.
@{x}: observation
@{shape}: the shape parameter of the distribution
@{location}: the location parameter of the distribution
@{scale}: the scale parameter of the distribution
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PSNORM

@CATEGORY=Statistics
@FUNCTION=R.DST
@SYNTAX=R.DST(x,n,shape,give_log)
@DESCRIPTION=This function returns the probability density function of the skew-t distribution.
@{x}: observation
@{n}: the number of degrees of freedom of the distribution
@{shape}: the shape parameter of the distribution
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=

@CATEGORY=Statistics
@FUNCTION=R.DT
@SYNTAX=R.DT(x,n,give_log)
@DESCRIPTION=This function returns the probability density function of the Student t distribution.
@{x}: observation
@{n}: the number of degrees of freedom of the distribution
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PT,R.QT

@CATEGORY=Statistics
@FUNCTION=R.DWEIBULL
@SYNTAX=R.DWEIBULL(x,shape,scale,give_log)
@DESCRIPTION=This function returns the probability density function of the Weibull distribution.
@{x}: observation
@{shape}: the shape parameter of the distribution
@{scale}: the scale parameter of the distribution
@{give_log}: if true, log of the result will be returned instead

@SEEALSO=R.PWEIBULL,R.QWEIBULL

@CATEGORY=Statistics
@FUNCTION=R.PBETA
@SYNTAX=R.PBETA(x,a,b,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the beta distribution.
@{x}: observation
@{a}: the first shape parameter of the distribution
@{b}: the second scale parameter of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DBETA,R.QBETA

@CATEGORY=Statistics
@FUNCTION=R.PBINOM
@SYNTAX=R.PBINOM(x,n,psuc,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the binomial distribution.
@{x}: observation
@{n}: the number of trials
@{psuc}: the probability of success in each trial
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DBINOM,R.QBINOM

@CATEGORY=Statistics
@FUNCTION=R.PCAUCHY
@SYNTAX=R.PCAUCHY(x,location,scale,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the Cauchy distribution.
@{x}: observation
@{location}: the center of the distribution
@{scale}: the scale parameter of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DCAUCHY,R.QCAUCHY

@CATEGORY=Statistics
@FUNCTION=R.PCHISQ
@SYNTAX=R.PCHISQ(x,df,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the chi-square distribution.
@{x}: observation
@{df}: the number of degrees of freedom of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DCHISQ,R.QCHISQ

@CATEGORY=Statistics
@FUNCTION=R.PEXP
@SYNTAX=R.PEXP(x,scale,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the exponential distribution.
@{x}: observation
@{scale}: the scale parameter of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DEXP,R.QEXP

@CATEGORY=Statistics
@FUNCTION=R.PF
@SYNTAX=R.PF(x,n1,n2,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the F distribution.
@{x}: observation
@{n1}: the first number of degrees of freedom of the distribution
@{n2}: the second number of degrees of freedom of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DF,R.QF

@CATEGORY=Statistics
@FUNCTION=R.PGAMMA
@SYNTAX=R.PGAMMA(x,shape,scale,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the gamma distribution.
@{x}: observation
@{shape}: the shape parameter of the distribution
@{scale}: the scale parameter of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DGAMMA,R.QGAMMA

@CATEGORY=Statistics
@FUNCTION=R.PGEOM
@SYNTAX=R.PGEOM(x,psuc,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the geometric distribution.
@{x}: observation
@{psuc}: the probability of success in each trial
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DGEOM,R.QGEOM

@CATEGORY=Statistics
@FUNCTION=R.PHYPER
@SYNTAX=R.PHYPER(x,r,b,n,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the hypergeometric distribution.
@{x}: observation
@{r}: the number of red balls
@{b}: the number of black balls
@{n}: the number of balls drawn
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DHYPER,R.QHYPER

@CATEGORY=Statistics
@FUNCTION=R.PLNORM
@SYNTAX=R.PLNORM(x,logmean,logsd,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the log-normal distribution.
@{x}: observation
@{logmean}: mean of the underlying normal distribution
@{logsd}: standard deviation of the underlying normal distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DLNORM,R.QLNORM

@CATEGORY=Statistics
@FUNCTION=R.PNBINOM
@SYNTAX=R.PNBINOM(x,n,psuc,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the negative binomial distribution.
@{x}: observation
@{n}: the number of trials
@{psuc}: the probability of success in each trial
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DNBINOM,R.QNBINOM

@CATEGORY=Statistics
@FUNCTION=R.PNORM
@SYNTAX=R.PNORM(x,mu,sigma,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the normal distribution.
@{x}: observation
@{mu}: mean of the distribution
@{sigma}: standard deviation of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DNORM,R.QNORM

@CATEGORY=Statistics
@FUNCTION=R.PPOIS
@SYNTAX=R.PPOIS(x,lambda,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the Poisson distribution.
@{x}: observation
@{lambda}: the mean of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DPOIS,R.QPOIS

@CATEGORY=Statistics
@FUNCTION=R.PSNORM
@SYNTAX=R.PSNORM(x,shape,location,scale,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the skew-normal distribution.
@{x}: observation
@{shape}: the shape parameter of the distribution
@{location}: the location parameter of the distribution
@{scale}: the scale parameter of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DSNORM

@CATEGORY=Statistics
@FUNCTION=R.PT
@SYNTAX=R.PT(x,n,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the Student t distribution.
@{x}: observation
@{n}: the number of degrees of freedom of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DT,R.QT

@CATEGORY=Statistics
@FUNCTION=R.PWEIBULL
@SYNTAX=R.PWEIBULL(x,shape,scale,lower_tail,log_p)
@DESCRIPTION=This function returns the cumulative distribution function of the Weibull distribution.
@{x}: observation
@{shape}: the shape parameter of the distribution
@{scale}: the scale parameter of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DWEIBULL,R.QWEIBULL

@CATEGORY=Statistics
@FUNCTION=R.QBETA
@SYNTAX=R.QBETA(p,a,b,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the beta distribution.
@{p}: probability
@{a}: the first shape parameter of the distribution
@{b}: the second scale parameter of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DBETA,R.PBETA

@CATEGORY=Statistics
@FUNCTION=R.QBINOM
@SYNTAX=R.QBINOM(x,n,psuc,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the binomial distribution.
@{x}: observation
@{n}: the number of trials
@{psuc}: the probability of success in each trial
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DBINOM,R.PBINOM

@CATEGORY=Statistics
@FUNCTION=R.QCAUCHY
@SYNTAX=R.QCAUCHY(p,location,scale,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the Cauchy distribution.
@{p}: probability
@{location}: the center of the distribution
@{scale}: the scale parameter of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DCAUCHY,R.PCAUCHY

@CATEGORY=Statistics
@FUNCTION=R.QCHISQ
@SYNTAX=R.QCHISQ(p,df,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the chi-square distribution.
@{p}: probability
@{df}: the number of degrees of freedom of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DCHISQ,R.PCHISQ

@CATEGORY=Statistics
@FUNCTION=R.QEXP
@SYNTAX=R.QEXP(p,scale,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the exponential distribution.
@{p}: probability
@{scale}: the scale parameter of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DEXP,R.PEXP

@CATEGORY=Statistics
@FUNCTION=R.QF
@SYNTAX=R.QF(x,n1,n2,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the F distribution.
@{x}: observation
@{n1}: the first number of degrees of freedom of the distribution
@{n2}: the second number of degrees of freedom of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DF,R.PF

@CATEGORY=Statistics
@FUNCTION=R.QGAMMA
@SYNTAX=R.QGAMMA(p,shape,scale,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the gamma distribution.
@{p}: probability
@{shape}: the shape parameter of the distribution
@{scale}: the scale parameter of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DGAMMA,R.PGAMMA

@CATEGORY=Statistics
@FUNCTION=R.QGEOM
@SYNTAX=R.QGEOM(p,psuc,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the geometric distribution.
@{p}: probability
@{psuc}: the probability of success in each trial
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DGEOM,R.PGEOM

@CATEGORY=Statistics
@FUNCTION=R.QHYPER
@SYNTAX=R.QHYPER(p,r,b,n,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the hypergeometric distribution.
@{p}: probability
@{r}: the number of red balls
@{b}: the number of black balls
@{n}: the number of balls drawn
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DHYPER,R.PHYPER

@CATEGORY=Statistics
@FUNCTION=R.QLNORM
@SYNTAX=R.QLNORM(x,logmean,logsd,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the log-normal distribution.
@{x}: observation
@{logmean}: mean of the underlying normal distribution
@{logsd}: standard deviation of the underlying normal distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DLNORM,R.PLNORM

@CATEGORY=Statistics
@FUNCTION=R.QNBINOM
@SYNTAX=R.QNBINOM(p,n,psuc,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the negative binomial distribution.
@{p}: probability
@{n}: the number of trials
@{psuc}: the probability of success in each trial
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DNBINOM,R.PNBINOM

@CATEGORY=Statistics
@FUNCTION=R.QNORM
@SYNTAX=R.QNORM(p,mu,sigma,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the normal distribution.
@{p}: probability
@{mu}: mean of the distribution
@{sigma}: standard deviation of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DNORM,R.PNORM

@CATEGORY=Statistics
@FUNCTION=R.QPOIS
@SYNTAX=R.QPOIS(p,lambda,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the Poisson distribution.
@{p}: probability
@{lambda}: the mean of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DPOIS,R.PPOIS

@CATEGORY=Statistics
@FUNCTION=R.QT
@SYNTAX=R.QT(p,n,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the Student t distribution.
@{p}: probability
@{n}: the number of degrees of freedom of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DT,R.PT

@CATEGORY=Statistics
@FUNCTION=R.QWEIBULL
@SYNTAX=R.QWEIBULL(p,shape,scale,lower_tail,log_p)
@DESCRIPTION=This function returns the probability quantile function, i.e., the inverse of the cumulative distribution function, of the Weibull distribution.
@{p}: probability
@{shape}: the shape parameter of the distribution
@{scale}: the scale parameter of the distribution
@{lower_tail}: if true (the default), the lower tail of the distribution is considered
@{log_p}: if true, log of the probability is used

@SEEALSO=R.DWEIBULL,R.PWEIBULL

@CATEGORY=Statistics
@FUNCTION=RANK
@SEEALSO=PERCENTRANK

@CATEGORY=Statistics
@FUNCTION=RAYLEIGH
@SEEALSO=RANDRAYLEIGH

@CATEGORY=Statistics
@FUNCTION=RAYLEIGHTAIL
@SEEALSO=RANDRAYLEIGHTAIL

@CATEGORY=Statistics
@FUNCTION=RSQ
@SYNTAX=RSQ(array1,array2)
@DESCRIPTION=Strings and empty cells are simply ignored.
@{array1}: first component values
@{array2}: second component values

@SEEALSO=CORREL,COVAR,INTERCEPT,LINEST,LOGEST,PEARSON,SLOPE,STEYX,TREND

@CATEGORY=Statistics
@FUNCTION=SKEW
@SYNTAX=SKEW(number1,number2)
@DESCRIPTION=Strings and empty cells are simply ignored.
@{number1}: first value
@{number2}: second value

@NOTE=This is only meaningful if the underlying distribution really has a third moment.  The skewness of a symmetric (e.g., normal) distribution is zero.
@NOTE=If less than three numbers are given, this function returns a #DIV/0! error.
@SEEALSO=AVERAGE,VAR,SKEWP,KURT

@CATEGORY=Statistics
@FUNCTION=SKEWP
@SYNTAX=SKEWP(number1,number2)
@DESCRIPTION=Strings and empty cells are simply ignored.
@{number1}: first value
@{number2}: second value

@NOTE=If less than two numbers are given, SKEWP returns a #DIV/0! error.
@SEEALSO=AVERAGE,VARP,SKEW,KURTP

@CATEGORY=Statistics
@FUNCTION=SLOPE
@SYNTAX=SLOPE(known_y's,known_x's)
@DESCRIPTION=.
@{known_y's}: known y-values
@{known_x's}: known x-values
@NOTE=If @{known_x} or @{known_y} contains no data entries or different number of data entries, this function returns a #N/A error.
@NOTE=If the variance of the @{known_x} is zero, this function returns #DIV/0 error.
@SEEALSO=STDEV,STDEVPA

@CATEGORY=Statistics
@FUNCTION=SMALL
@SYNTAX=SMALL(data,k)
@DESCRIPTION=.
@{data}: data set
@{k}: which value to find
@NOTE=If data set is empty this function returns a #NUM! error.
@NOTE=If @{k} <= 0 or @{k} is greater than the number of data items given this function returns a #NUM! error.
@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,LARGE

@CATEGORY=Statistics
@FUNCTION=SSMEDIAN
@SYNTAX=SSMEDIAN(array,interval)
@DESCRIPTION=The data points given in @{array} are assumed to be the result of grouping data into intervals of length @{interval}
@{array}: data set
@{interval}: length of each grouping interval, defaults to 1

@NOTE=If @{array} is empty, this function returns a #NUM! error.
@NOTE=If @{interval} <= 0, this function returns a #NUM! error.SSMEDIAN does not check whether the data points are at least @{interval} apart.
@SEEALSO=MEDIAN

@CATEGORY=Statistics
@FUNCTION=STANDARDIZE
@SYNTAX=STANDARDIZE(x,mean,stddev)
@DESCRIPTION=.
@{x}: value
@{mean}: mean of the original distribution
@{stddev}: standard deviation of the original distribution
@NOTE=If @{stddev} is 0 this function returns a #DIV/0! error.
@SEEALSO=AVERAGE

@CATEGORY=Statistics
@FUNCTION=STDEV
@SYNTAX=STDEV(area1,area2)
@DESCRIPTION=STDEV is also known as the N-1-standard deviation. Under reasonable conditions, it is the maximum-likelihood estimator for the true population standard deviation.
@{area1}: first cell area
@{area2}: second cell area

@DESCRIPTION=To obtain the population standard deviation of a whole population use STDEVP.
@SEEALSO=AVERAGE,DSTDEV,DSTDEVP,STDEVA,STDEVPA,VAR

@CATEGORY=Statistics
@FUNCTION=STDEVA
@SYNTAX=STDEVA(area1,area2)
@DESCRIPTION=STDEVA is also known as the N-1-standard deviation. Under reasonable conditions, it is the maximum-likelihood estimator for the true population standard deviation.
@{area1}: first cell area
@{area2}: second cell area

@DESCRIPTION=To obtain the population standard deviation of a whole population use STDEVPA.
@DESCRIPTION=Numbers, text and logical values are included in the calculation too. If the cell contains text or the argument evaluates to FALSE, it is counted as value zero (0). If the argument evaluates to TRUE, it is counted as one (1). Note that empty cells are not counted.
@SEEALSO=STDEV,STDEVPA

@CATEGORY=Statistics
@FUNCTION=STDEVP
@SYNTAX=STDEVP(area1,area2)
@DESCRIPTION=This is also known as the N-standard deviation
@{area1}: first cell area
@{area2}: second cell area

@SEEALSO=STDEV,STDEVA,STDEVPA

@CATEGORY=Statistics
@FUNCTION=STDEVPA
@SYNTAX=STDEVPA(area1,area2)
@DESCRIPTION=This is also known as the N-standard deviation
@{area1}: first cell area
@{area2}: second cell area

@DESCRIPTION=Numbers, text and logical values are included in the calculation too. If the cell contains text or the argument evaluates to FALSE, it is counted as value zero (0). If the argument evaluates to TRUE, it is counted as one (1). Note that empty cells are not counted.
@SEEALSO=STDEVA,STDEVP

@CATEGORY=Statistics
@FUNCTION=STEYX
@SYNTAX=STEYX(known_y's,known_x's)
@DESCRIPTION=.
@{known_y's}: known y-values
@{known_x's}: known x-values
@NOTE=If @{known_y}'s and @{known_x}'s are empty or have a different number of arguments then this function returns a #N/A error.
@SEEALSO=PEARSON,RSQ,SLOPE

@CATEGORY=Statistics
@FUNCTION=SUBTOTAL
@SEEALSO=COUNT,SUM

@CATEGORY=Statistics
@FUNCTION=TDIST
@SYNTAX=TDIST(x,dof,tails)
@DESCRIPTION=The survival function is 1 minus the cumulative distribution function.
@{x}: 
@{dof}: number of degrees of freedom
@{tails}: 1 or 2. If this is 2, @{x} is replaced by the absolute value and the returned value is multiplied by 2

@NOTE=If @{dof} < 1 this function returns a #NUM! error.
@NOTE=If @{tails} is neither 1 or 2 this function returns a #NUM! error.
@NOTE=The parameterization of this function is different from what is used for, e.g., NORMSDIST.  This is a common source of mistakes, but necessary for compatibility.
@DESCRIPTION=This function is Excel compatible for non-negative @{x}.
@SEEALSO=TINV,TTEST

@CATEGORY=Statistics
@FUNCTION=TINV
@SYNTAX=TINV(p,dof)
@DESCRIPTION=The survival function is 1 minus the cumulative distribution function.
@{p}: probability
@{dof}: number of degrees of freedom

@NOTE=If @{p} < 0 or @{p} > 1 or @{dof} < 1 this function returns a #NUM! error.
@NOTE=The parameterization of this function is different from what is used for, e.g., NORMSINV.  This is a common source of mistakes, but necessary for compatibility.
@SEEALSO=TDIST,TTEST

@CATEGORY=Statistics
@FUNCTION=TREND
@SYNTAX=TREND(known_y's,known_x's,new_x's,const)
@DESCRIPTION=.
@{known_y's}: known y-values
@{known_x's}: known x-values; if @{known_x}'s is omitted, an array {1, 2, 3, ...} is used.
@{new_x's}:  x-values for which you want to estimate the y-values; defaults to @{known_x}'s
@{const}: if this is false the line will be forced to go through the origin; defaults to TRUE
@NOTE=If @{known_y's} and @{known_x's} have unequal number of data points, this function returns a #NUM! error.
@SEEALSO=LINEST

@CATEGORY=Statistics
@FUNCTION=TRIMMEAN
@SYNTAX=TRIMMEAN(ref,fraction)
@DESCRIPTION=If @{fraction}=0.2 and the data set contains 40 numbers, 8 numbers are trimmed from the data set (40 x 0.2): the 4 largest and the 4 smallest. To avoid a bias, the number of points to be excluded is always rounded down to the nearest even number.
@{ref}: list of numbers whose mean you want to calculate
@{fraction}: fraction of the data set excluded from the mean

@SEEALSO=AVERAGE,GEOMEAN,HARMEAN,MEDIAN,MODE

@CATEGORY=Statistics
@FUNCTION=TTEST
@SYNTAX=TTEST(array1,array2,tails,type)
@DESCRIPTION=.
@{array1}: sample from the first population
@{array2}: sample from the second population
@{tails}: number of tails to consider
@{type}: Type of test to perform. 1 indicates a test for paired variables, 2 a test of unpaired variables with equal variances, and 3 a test of unpaired variables with unequal variances
@NOTE=If the data sets contain a different number of data points and the test is paired (@{type} one), TTEST returns the #N/A error.
@NOTE=@{tails} and @{type} are truncated to integers.
@NOTE=If @{tails} is not one or two, this function returns a #NUM! error.
@NOTE=If @{type} is any other than one, two, or three, this function returns a #NUM! error.
@SEEALSO=FDIST,FINV

@CATEGORY=Statistics
@FUNCTION=VAR
@SYNTAX=VAR(area1,area2)
@DESCRIPTION=VAR is also known as the N-1-variance. Under reasonable conditions, it is the maximum-likelihood estimator for the true variance.
@{area1}: first cell area
@{area2}: second cell area

@SEEALSO=VARP,STDEV

@CATEGORY=Statistics
@FUNCTION=VARA
@SYNTAX=VARA(area1,area2)
@DESCRIPTION=VARA is also known as the N-1-variance. Under reasonable conditions, it is the maximum-likelihood estimator for the true variance
@{area1}: first cell area
@{area2}: second cell area

@DESCRIPTION=To get the true variance of a complete population use VARPA.
@DESCRIPTION=Numbers, text and logical values are included in the calculation too. If the cell contains text or the argument evaluates to FALSE, it is counted as value zero (0). If the argument evaluates to TRUE, it is counted as one (1). Note that empty cells are not counted.
@SEEALSO=VAR,VARPA

@CATEGORY=Statistics
@FUNCTION=VARP
@SYNTAX=VARP(area1,area2)
@DESCRIPTION=VARP is also known as the N-variance.
@{area1}: first cell area
@{area2}: second cell area

@SEEALSO=AVERAGE,DVAR,DVARP,STDEV,VAR

@CATEGORY=Statistics
@FUNCTION=VARPA
@SYNTAX=VARPA(area1,area2)
@DESCRIPTION=VARPA is also known as the N-variance.
@{area1}: first cell area
@{area2}: second cell area

@DESCRIPTION=Numbers, text and logical values are included in the calculation too. If the cell contains text or the argument evaluates to FALSE, it is counted as value zero (0). If the argument evaluates to TRUE, it is counted as one (1). Note that empty cells are not counted.
@SEEALSO=VARA,VARP

@CATEGORY=Statistics
@FUNCTION=WEIBULL
@SYNTAX=WEIBULL(x,alpha,beta,cumulative)
@DESCRIPTION=If the @{cumulative} boolean is true it will return: 1 - exp (-(@{x}/@{beta})^@{alpha}),otherwise it will return (@{alpha}/@{beta}^@{alpha}) * @{x}^(@{alpha}-1) * exp(-(@{x}/@{beta}^@{alpha})).
@{x}: 
@{alpha}: scale parameter
@{beta}: scale parameter
@{cumulative}: whether to evaluate the density function or the cumulative distribution function

@NOTE=If @{x} < 0 this function returns a #NUM! error.
@NOTE=If @{alpha} <= 0 or @{beta} <= 0 this function returns a #NUM! error.
@SEEALSO=POISSON

@CATEGORY=Statistics
@FUNCTION=ZTEST
@SYNTAX=ZTEST(ref,x,stddev)
@DESCRIPTION=.
@{ref}: data set
@{x}: mean as given in the null hypothesis
@{stddev}: population standard deviation, defaults to the sample standard deviation
@NOTE=If @{ref} contains less than two data items ZTEST returns #DIV/0! error.
@SEEALSO=CONFIDENCE,NORMDIST,NORMINV,NORMSDIST,NORMSINV,STANDARDIZE

@CATEGORY=String
@FUNCTION=ASC
@SYNTAX=ASC(text)
@DESCRIPTION=ASC converts full-width katakana and ASCII characters to half-width equivalent characters, copying all others. 
@{text}: string

@DESCRIPTION=The distinction between half-width and full-width characters is described in http://www.unicode.org/reports/tr11/.
@NOTE=While in obsolete encodings ASC used to translate between 2-byte and 1-byte characters, this is not the case in UTF-8.
@SEEALSO=JIS

@CATEGORY=String
@FUNCTION=CHAR
@SYNTAX=CHAR(x)
@DESCRIPTION=CHAR(@{x}) returns the CP1252 (Windows-1252) character with code @{x}.
@{x}: code point

@DESCRIPTION=@{x} must be in the range 1 to 255.
@DESCRIPTION=CP1252 (Windows-1252) is also known as the "ANSI code page", but it is not an ANSI standard.
@DESCRIPTION=CP1252 (Windows-1252) is based on an early draft of ISO-8859-1, and contains all of its printable characters (but partially at different positions.)
@NOTE=In CP1252 (Windows-1252), 129, 141, 143, 144, and 157 do not have matching characters.
@NOTE=For @{x} from 1 to 255 except 129, 141, 143, 144, and 157 we have CODE(CHAR(@{x}))=@{x}.
@DESCRIPTION=This function is Excel compatible.
@SEEALSO=CODE

@CATEGORY=String
@FUNCTION=CLEAN
@SYNTAX=CLEAN(text)
@DESCRIPTION=CLEAN removes non-printable characters from its argument leaving only regular characters and white-space.
@{text}: string


@CATEGORY=String
@FUNCTION=CODE
@SYNTAX=CODE(c)
@DESCRIPTION=@{c} must be a valid CP1252 (Windows-1252) character.
@{c}: character

@DESCRIPTION=CP1252 (Windows-1252) is also known as the "ANSI code page", but it is not an ANSI standard.
@DESCRIPTION=CP1252 (Windows-1252) is based on an early draft of ISO-8859-1, and contains all of its printable characters (but partially at different positions.)
@NOTE=In CP1252 (Windows-1252), 129, 141, 143, 144, and 157 do not have matching characters.
@NOTE=For @{x} from 1 to 255 except 129, 141, 143, 144, and 157 we have CODE(CHAR(@{x}))=@{x}.
@DESCRIPTION=This function is Excel compatible.
@SEEALSO=CHAR

@CATEGORY=String
@FUNCTION=CONCATENATE
@SEEALSO=LEFT,MID,RIGHT

@CATEGORY=String
@FUNCTION=DOLLAR
@SEEALSO=FIXED,TEXT,VALUE

@CATEGORY=String
@FUNCTION=EXACT
@SEEALSO=LEN,SEARCH,DELTA

@CATEGORY=String
@FUNCTION=FIND
@SYNTAX=FIND(string1,string2,start)
@DESCRIPTION=.
@{string1}: search string
@{string2}: search field
@{start}: starting position, defaults to 1
@NOTE=This search is case-sensitive.
@SEEALSO=EXACT,LEN,MID,SEARCH

@CATEGORY=String
@FUNCTION=FINDB
@SYNTAX=FINDB(string1,string2,start)
@DESCRIPTION=.
@{string1}: search string
@{string2}: search field
@{start}: starting byte position, defaults to 1
@NOTE=This search is case-sensitive.
@SEEALSO=FIND,LEFTB,RIGHTB,LENB,LEFT,MID,RIGHT,LEN

@CATEGORY=String
@FUNCTION=FIXED
@SEEALSO=TEXT,VALUE,DOLLAR

@CATEGORY=String
@FUNCTION=JIS
@SYNTAX=JIS(text)
@DESCRIPTION=JIS converts half-width katakana and ASCII characters to full-width equivalent characters, copying all others. 
@{text}: original text

@DESCRIPTION=The distinction between half-width and full-width characters is described in http://www.unicode.org/reports/tr11/.
@NOTE=While in obsolete encodings JIS used to translate between 1-byte and 2-byte characters, this is not the case in UTF-8.
@SEEALSO=ASC

@CATEGORY=String
@FUNCTION=LEFT
@SYNTAX=LEFT(s,num_chars)
@DESCRIPTION=.
@{s}: the string
@{num_chars}: the number of characters to return (defaults to 1)
@NOTE=If the string @{s} is in a right-to-left script, the returned first characters are from the right of the string.
@SEEALSO=MID,RIGHT,LEN,MIDB,RIGHTB,LENB

@CATEGORY=String
@FUNCTION=LEFTB
@SYNTAX=LEFTB(s,num_bytes)
@DESCRIPTION=.
@{s}: the string
@{num_bytes}: the maximum number of bytes to return (defaults to 1)
@NOTE=The semantics of this function is subject to change as various applications implement it.
@NOTE=If the string is in a right-to-left script, the returned first characters are from the right of the string.
@SEEALSO=MIDB,RIGHTB,LENB,LEFT,MID,RIGHT,LEN

@CATEGORY=String
@FUNCTION=LEN
@SEEALSO=CHAR,CODE,LENB

@CATEGORY=String
@FUNCTION=LENB
@SEEALSO=CHAR, CODE, LEN

@CATEGORY=String
@FUNCTION=LOWER
@SEEALSO=UPPER

@CATEGORY=String
@FUNCTION=MID
@SEEALSO=LEFT,RIGHT,LEN,LEFTB,MIDB,RIGHTB,LENB

@CATEGORY=String
@FUNCTION=MIDB
@SYNTAX=MIDB(s,start_pos,num_bytes)
@DESCRIPTION=.
@{s}: the string
@{start_pos}: the number of the byte with which to start (defaults to 1)
@{num_bytes}: the maximum number of bytes to return (defaults to 1)
@NOTE=The semantics of this function is subject to change as various applications implement it.
@SEEALSO=LEFTB,RIGHTB,LENB,LEFT,MID,RIGHT,LEN

@CATEGORY=String
@FUNCTION=NUMBERVALUE
@SYNTAX=NUMBERVALUE(text,separator)
@DESCRIPTION=.
@{text}: string
@{separator}: decimal separator
@NOTE=If @{text} does not look like a decimal number, NUMBERVALUE returns the value VALUE would return (ignoring the given @{separator}).
@SEEALSO=VALUE

@CATEGORY=String
@FUNCTION=PROPER
@SEEALSO=LOWER,UPPER

@CATEGORY=String
@FUNCTION=REPLACE
@SEEALSO=MID,SEARCH,SUBSTITUTE,TRIM

@CATEGORY=String
@FUNCTION=REPLACEB
@SYNTAX=REPLACEB(old,start,num,new)
@DESCRIPTION=REPLACEB replaces the string of valid unicode characters starting at the byte @{start} and ending at @{start}+@{num}-1 with the string @{new}.
@{old}: original text
@{start}: starting byte position
@{num}: number of bytes to be replaced
@{new}: replacement string

@NOTE=The semantics of this function is subject to change as various applications implement it.
@SEEALSO=MID,SEARCH,SUBSTITUTE,TRIM

@CATEGORY=String
@FUNCTION=REPT
@SEEALSO=CONCATENATE

@CATEGORY=String
@FUNCTION=RIGHT
@SYNTAX=RIGHT(s,num_chars)
@DESCRIPTION=.
@{s}: the string
@{num_chars}: the number of characters to return (defaults to 1)
@NOTE=If the string @{s} is in a right-to-left script, the returned last characters are from the left of the string.
@SEEALSO=LEFT,MID,LEN,LEFTB,MIDB,RIGHTB,LENB

@CATEGORY=String
@FUNCTION=RIGHTB
@SYNTAX=RIGHTB(s,num_bytes)
@DESCRIPTION=.
@{s}: the string
@{num_bytes}: the maximum number of bytes to return (defaults to 1)
@NOTE=The semantics of this function is subject to change as various applications implement it.
@NOTE=If the string @{s} is in a right-to-left script, the returned last characters are from the left of the string.
@SEEALSO=LEFTB,MIDB,LENB,LEFT,MID,RIGHT,LEN

@CATEGORY=String
@FUNCTION=SEARCH
@SYNTAX=SEARCH(search,text,start)
@DESCRIPTION=@{search} may contain wildcard characters (*) and question marks (?). A question mark matches any single character, and a wildcard matches any string including the empty string. To search for * or ?, precede the symbol with ~.
@{search}: search string
@{text}: search field
@{start}: starting position, defaults to 1

@NOTE=This search is not case sensitive.
@NOTE=If @{search} is not found, SEARCH returns #VALUE!
@NOTE=If @{start} is less than one or it is greater than the length of @{text}, SEARCH returns #VALUE!
@SEEALSO=FIND,SEARCHB

@CATEGORY=String
@FUNCTION=SEARCHB
@SYNTAX=SEARCHB(search,text,start)
@DESCRIPTION=@{search} may contain wildcard characters (*) and question marks (?). A question mark matches any single character, and a wildcard matches any string including the empty string. To search for * or ?, precede the symbol with ~.
@{search}: search string
@{text}: search field
@{start}: starting byte position, defaults to 1

@NOTE=This search is not case sensitive.
@NOTE=If @{search} is not found, SEARCH returns #VALUE!
@NOTE=If @{start} is less than one or it is greater than the byte length of @{text}, SEARCH returns #VALUE!
@NOTE=The semantics of this function is subject to change as various applications implement it.
@SEEALSO=FINDB,SEARCH

@CATEGORY=String
@FUNCTION=SUBSTITUTE
@SEEALSO=REPLACE,TRIM

@CATEGORY=String
@FUNCTION=T
@SEEALSO=CELL,N,VALUE

@CATEGORY=String
@FUNCTION=TEXT
@SEEALSO=DOLLAR,FIXED,VALUE

@CATEGORY=String
@FUNCTION=TRIM
@SEEALSO=CLEAN,MID,REPLACE,SUBSTITUTE

@CATEGORY=String
@FUNCTION=UNICHAR
@SEEALSO=CHAR,UNICODE,CODE

@CATEGORY=String
@FUNCTION=UNICODE
@SEEALSO=UNICHAR,CODE,CHAR

@CATEGORY=String
@FUNCTION=UPPER
@SEEALSO=LOWER

@CATEGORY=String
@FUNCTION=VALUE
@SEEALSO=DOLLAR,FIXED,TEXT

@CATEGORY=Time Series Analysis
@FUNCTION=FOURIER
@SYNTAX=FOURIER(Sequence,Inverse)
@DESCRIPTION=This array function returns the Fourier or inverse Fourier transform of the given data sequence.
@{Sequence}:  the data sequence to be transformed
@{Inverse}: if false, the inverse Fourier transform is calculated. Defaults to false

@DESCRIPTION=The output consists always of one column of complex numbers.
@NOTE=If @{Sequence} is neither an n by 1 nor 1 by n array, this function returns #NUM!

@CATEGORY=Time Series Analysis
@FUNCTION=INTERPOLATION
@SYNTAX=INTERPOLATION(abscissas,ordinates,targets,interpolation)
@DESCRIPTION=If an interpolation method is used, the number of returned values is one less than the number of targets and the targets values must be given in increasing order.
@{abscissas}: The abscissas of the data to interpolate.
@{ordinates}: The ordinates of the data to interpolate.
@{targets}: The abscissas of the interpolated data.
@{interpolation}: The method of interpolation to be used, defaults to no interpolation

@DESCRIPTION=The output consists always of one column of numbers.
@DESCRIPTION=Possible interpolation methods are:
0: linear;
1: linear with averaging;
2: staircase;
3: staircase with averaging;
4: natural cubic spline;
5: natural cubic spline with averaging.
@NOTE=Strings and empty cells in @{abscissas} and @{ordinates} are ignored.
@NOTE=If several target data are provided they must be in the same column in consecutive cells.
@SEEALSO=PERIODOGRAM

@CATEGORY=Time Series Analysis
@FUNCTION=PERIODOGRAM
@SYNTAX=PERIODOGRAM(ordinates,filter,abscissas,interpolation,number)
@DESCRIPTION=If an interpolation method is used, the number of returned values is one less than the number of targets and the targets values must be given in increasing order.
@{ordinates}: The ordinates of the data to interpolate.
@{filter}: Window function to  be used, defaults to no window function.
@{abscissas}: The abscissas of the data to interpolate, defaults to regularly spaced abscissa.
@{interpolation}: The method of interpolation to be used, defaults to no interpolation
@{number}:  Number of interpolated data points to be used.

@DESCRIPTION=The output consists always of one column of numbers.
@DESCRIPTION=Possible interpolation methods are:
0: linear;
1: linear with averaging;
2: staircase;
3: staircase with averaging;
4: natural cubic spline;
5: natural cubic spline with averaging.
@DESCRIPTION=Possible window functions are:
0: no filter (rectangular window)
1: Bartlett (triangular window)
2: Hahn (cosine window)
3: Welch (parabolic window)
@NOTE=Strings and empty cells in @{abscissas} and @{ordinates} are ignored.
@NOTE=If several target data are provided they must be in the same column in consecutive cells.
@SEEALSO=INTERPOLATION

