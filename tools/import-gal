#!/usr/bin/perl -w
# -----------------------------------------------------------------------------

use strict;

$| = 1;

my $myself = $0;
$myself =~ s|^.*/||;

die "$0: must run from top-level gnumeric directory.\n"
    unless -r "gnumeric-config.h.in";
my $dstdir = "src/widgets";

my $galdir = $ARGV[0];
$galdir = "../gal" unless defined $galdir;
die "$0: must specify gal directory on command line.\n"
    unless -d $galdir;

-d $dstdir or mkdir $dstdir or
    die "$0: cannot mkdir $dstdir: $!\n";

my @files = ("color-group.c", "color-group.h",
	     # Now changed in Gnumeric tree.
	     # "color-palette.c", "color-palette.h",
	     # "widget-color-combo.c", "widget-color-combo.h",
	     # "widget-pixmap-combo.c", "widget-pixmap-combo.h",
	     #"gtk-combo-box.c", "gtk-combo-box.h",
	     "gtk-combo-stack.c", "gtk-combo-stack.h",
	     );
my $srcdir = "$galdir/gal/widgets";

foreach my $file (@files) {
    local (*SRC,*DST);
    open (SRC, "<$srcdir/$file") or
	die "$0: Cannot read $srcdir/$file: $!\n";
    open (DST, ">$dstdir/$file.new") or
	die "$0: Cannot write $dstdir/$file.new: $!\n";

    print STDERR "Creating $dstdir/$file...";

    my $def = '';
    my $cb_screen = 0;
    my $has_gtkinclude = 0;

    print DST "/* File import from gal to gnumeric by $myself.  Do not edit.  */\n\n";

    if ($file =~ /^(gtk-combo-stack\.c)/) {
	print DST "#undef GTK_DISABLE_DEPRECATED\n";
	print DST "#warning \"This file uses GTK_DISABLE_DEPRECATED\"\n";
    }

    while (<SRC>) {
	chomp;

	if (m|^\s*\#\s*include\s*[<"]gal/util/e-util\.h[">]|) {
	    print DST "#include <gnm-marshalers.h>\n";
	    print DST "#include <gsf/gsf-impl-utils.h>\n";
	    next;
	}
	s|config.h|gnumeric-config.h| if /^\s*\#\s*include/;
	s|gal/widgets|widgets| if /^\s*\#\s*include/;

	if (m|^\s*\#\s*include\s*[<"].*e-colors\.h[">]|) {
	    print DST "#include <gui-util.h>\n";
	    print DST "#include <style-color.h>\n";
	    next;
	}

	if (m|^\s*\#\s*include\s*[<"]gal/util/e-i18n\.h[">]|) {
	    print DST "#include <gnumeric-i18n.h>\n";
	    next;
	}

	if (m|^\s*\#\s*include\s*[<"]gtk/gtk.*\.h[">]|) {
	    print DST "#include <gtk/gtk.h>\n" unless $has_gtkinclude;
	    $has_gtkinclude = 1;
	    next;
	}

	if (/^E_MAKE_TYPE/ ... /\)/) {
	    $def = '' if /^E_MAKE_TYPE/;
	    $def .= $_;

	    if (/\)/) {
		$def =~ /\((.*)\s*,\s*(.*)\s*,\s*(.*)\s*,\s*(.*)\s*,\s*(.*)\s*,\s*(.*)\s*\)/;
		print DST "GSF_CLASS($3,$1,$4,$5,$6)\n";
	    }
	    next;
	}

	# Fix const bug.
	if (/^struct _ColorNamePair/ ... /^\};/) {
	    s/char\s*\*/const char */;
	}

	if (s/\be_marshal_/gnm__/g) {
	    s/NONE/VOID/g;
	}

	if (s/\bgtk_widget_set_usize\b/gtk_widget_set_size_request/g) {
	    s/\b0\b/-1/;
	}

	s/\bgdk_(gc|pixbuf|pixmap)_unref\b/g_object_unref/g;
	s/\bgdk_cursor_destroy\b/gdk_cursor_unref/g;
	s/\be_dark_gray\b/gs_dark_gray/g;
	s/\bE_OBJECT_CLASS_TYPE\b/G_TYPE_FROM_CLASS/g;
	s/\bgdk_draw_pixmap\b/gdk_draw_drawable/g;

	s/\bE_OBJECT_CLASS_ADD_SIGNALS[^;]*;//;

	s/gtk_object_(get|set)_user_data\s*\(GTK_OBJECT\s*\(([a-z]+)\)/g_object_$1_data \(G_OBJECT \($2\), "gal"/;

	# Fix multi-head bug.
	# Fix colour space bug.
	if (s/\be_color_alloc_gdk\s*\(NULL,\s*&([a-z_]+)\)/gdk_colormap_alloc_color \(gtk_widget_get_colormap \(color_picker\), &$1, FALSE, TRUE\)/) {
	    $_ .= "\n\tgdk_colormap_query_color (gtk_widget_get_colormap (color_picker), $1.pixel, &$1);";
	}

	# Fix colour space bug.
	s/gdk_rgb_find_color\s*\(([^,]+),\s*(.*)\);/{ gdk_colormap_alloc_color \($1, $2, FALSE, TRUE\); gdk_colormap_query_color \($1, $2->pixel, $2); }/;

	# Fix multi-head bug.
	s/\bgdk_cursor_new\s*\(/gdk_cursor_new_for_display \(gtk_widget_get_display \(GTK_WIDGET \(combo_box\)\), /;

	# Fix multi-head bug.
	if ($file eq 'gtk-combo-stack.c') {
	    if ($_ eq '}' && $cb_screen == 0) {
		$cb_screen = 1;	
		print DST "$_\n\n";
		&cb_screen ("GtkComboStack", "cs", "cs->priv->scrolled_window ? cs->priv->scrolled_window : cs->priv->list");
		next;
	    } elsif (/g_signal_connect/ && $cb_screen == 1) {
		$cb_screen = 2;
		&attach_cb_screen ("combo");
	    }
	}

	# Fix multi-head bug.
	if ($file eq 'widget-pixmap-combo.c') {
	    if ($_ eq '}' && $cb_screen == 0) {
		$cb_screen = 1;	
		print DST "$_\n\n";
		&cb_screen ("PixmapCombo", "pc", "pc->combo_table");
		next;
	    } elsif (/g_signal_connect.*preview_button/ && $cb_screen == 1) {
		$cb_screen = 2;
		&attach_cb_screen ("pc");
	    }
	}

	# Fix multi-head bug.
	if ($file eq 'widget-color-combo.c') {
	    if ($_ eq '}' && $cb_screen == 0) {
		$cb_screen = 1;	
		print DST "$_\n\n";
		&cb_screen ("ColorCombo", "cc", "GTK_WIDGET (cc->palette)");
		next;
	    } elsif (/g_signal_connect.*preview_button/ && $cb_screen == 1) {
		$cb_screen = 2;
		&attach_cb_screen ("cc");
	    }
	}

	if ($file =~ /^widget-color-combo\.[ch]$/) {
	    print DST "\tGdkColor  default_color_save;\n" if /GdkColor\s*\*default_color;/;
	    s/GdkColor/const GdkColor/ if /GdkColor\s*\*default_color,/;
	    s/=\s*default_color/= default_color ? (cc->default_color_save = *default_color), &cc->default_color_save : NULL/
		if /cc->default_color\s*=\s*default_color;/;
	}

	if ($file =~ /^(color-palette|widget-color-combo)\.[ch]$/) {
	    s/GnomeCanvas/FooCanvas/g;
	    s/gnome_canvas/foo_canvas/g;
	    s/GNOME_CANVAS/FOO_CANVAS/g;
	    s/GNOME_TYPE_CANVAS_PIXBUF/FOO_TYPE_CANVAS_PIXBUF/;
	    s|libgnomecanvas/gnome-|libfoocanvas/foo-|;
	}

	if ($file =~ /^widget-color-combo\.[ch]$/) {
	    print DST "#include <libfoocanvas/foo-canvas.h>\n"
		if m|^\#include <widgets/color-palette\.h>|;
	    s|gtk/gtkwidget\.h|gtk/gtk.h|;
	}

	s/\s+$//;

	print DST "$_\n";
    }

    close (*SRC);
    close (*DST);

    &update_file ("$dstdir/$file");
}

# -----------------------------------------------------------------------------

sub cb_screen {
    my ($type,$var,$widget) = @_;

    print DST "static void\n";
    print DST "cb_screen_changed ($type *$var, GdkScreen *previous_screen)\n";
    print DST "{\n";
    print DST "\tGtkWidget *w = GTK_WIDGET ($var);\n";
    print DST "\tGdkScreen *screen = gtk_widget_has_screen (w)\n";
    print DST "\t\t? gtk_widget_get_screen (w)\n";
    print DST "\t\t: NULL;\n";
    print DST "\n";
    print DST "\tif (screen) {\n";
    print DST "\t\tGtkWidget *toplevel = gtk_widget_get_toplevel ($widget);\n";
    print DST "\t\tgtk_window_set_screen (GTK_WINDOW (toplevel), screen);\n";
    print DST "\t}\n";
    print DST "}\n";
}

sub attach_cb_screen {
    my ($var) = @_;
    print DST "\tg_signal_connect (G_OBJECT ($var), \"screen-changed\", G_CALLBACK (cb_screen_changed), NULL);\n";
}

# -----------------------------------------------------------------------------

sub update_file {
    my ($old) = @_;
    my ($new) = "$old.new";

    if (!-r $old) {
	rename $new, $old or
	    die "$0: Cannot rename $new to $old: $!\n";
	print STDERR " -- done.\n";
    } else {
	system ("cmp '$old' '$new' >/dev/null");
	if ($? == 0) {
	    print STDERR " -- unchanged.\n";
	    unlink $new;
	} else {
	    rename $new, $old or
		die "$0: Cannot rename $new to $old: $!\n";
	    print STDERR " -- done.\n";
	}
    }
}

# -----------------------------------------------------------------------------
