#!/usr/bin/perl -w

use strict;
use XML::Parser;

my @schemas = ();

for my $filename (@ARGV) {
    my $parser = new XML::Parser ('Style' => 'Tree');
    my $tree = $parser->parsefile ($filename);

    &walk_tree ([], [{},@$tree]);
}
@schemas = sort { $a->{'applyto'} cmp $b->{'applyto'} } @schemas;
my $N = @schemas;

# Number the schemas and decide on a variable name.
{
    my $i = 0;
    foreach my $schema (@schemas) {
	$schema->{'i'} = $i++;

	my $var = $schema->{'applyto'};
	$var =~ s{^/apps/gnumeric/}{};
	$var =~ s{^/apps/gnome-settings/gnumeric/}{};
	$var =~ s{[^a-zA-Z0-9_]}{_}g;
	$schema->{'var'} = $var;
    }
}

my $cfile = "";
my $hfile = "";

my %type_to_ctype =
    ('bool' => 'gboolean',
     'int' => 'int',
     'float' => 'double',
     'string' => 'const char *',
     'list:string' => 'GSList *',
     'GO_TYPE_DIRECTION' => 'GODirection',
     'GTK_TYPE_UNIT' => 'GtkUnit',
    );

my %extra_attributes =
    ('/apps/gnumeric/core/gui/editing/enter_moves_dir' => {
	'gtype' => 'GO_TYPE_DIRECTION',
	'default' => 'GO_DIRECTION_DOWN',  # Should match schema
     },

     '/apps/gnumeric/printsetup/preferred-unit' => {
	 'gtype' => 'GTK_TYPE_UNIT',
	 'default' => 'GTK_UNIT_MM',  # Should match schema
     },

     '/apps/gnumeric/core/gui/editing/recalclag' => {
	 'min' => -5000,
	 'max' => 5000
     },

     '/apps/gnumeric/core/gui/toolbars/FormatToolbar-position' => {
	 'min' => 0,
	 'max' => 3,
     },

     '/apps/gnumeric/core/gui/toolbars/ObjectToolbar-position' => {
	 'min' => 0,
	 'max' => 3,
     },

     '/apps/gnumeric/core/gui/toolbars/StandardToolbar-position' => {
	 'min' => 0,
	 'max' => 3,
     },

     '/apps/gnumeric/core/sort/dialog/max-initial-clauses' => {
	 'min' => 0,
	 'max' => 256,
     },

     '/apps/gnumeric/core/workbook/n-cols' => {
	 'min' => 'GNM_MIN_COLS',
	 'max' => 'GNM_MAX_COLS',
     },

     '/apps/gnumeric/core/workbook/n-rows' => {
	 'min' => 'GNM_MIN_ROWS',
	 'max' => 'GNM_MAX_ROWS',
     },

     '/apps/gnumeric/core/workbook/n-sheet' => {
	 'min' => 1,
	 'max' => 64,
     },

     '/apps/gnumeric/core/workbook/autosave_time' => {
	 'min' => 0,
	 'max' => '365 * 24 * 60 * 60',
     },

     '/apps/gnumeric/core/xml/compression-level' => {
	 'min' => 0,
	 'max' => 9,
     },

     '/apps/gnumeric/functionselector/num-of-recent' => {
	 'min' => 0,
	 'max' => 40,
     },

     '/apps/gnumeric/printsetup/paper-orientation' => {
	 'min' => 'GTK_PAGE_ORIENTATION_PORTRAIT',
	 'max' => 'GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE',
     },

     '/apps/gnumeric/printsetup/scale-height' => {
	 'min' => 0,
	 'max' => 100,
     },

     '/apps/gnumeric/printsetup/scale-width' => {
	 'min' => 0,
	 'max' => 100,
     },

     '/apps/gnumeric/undo/max_descriptor_width' => {
	 'min' => 5,
	 'max' => 256,
     },

     '/apps/gnumeric/undo/maxnum' => {
	 'min' => 0,
	 'max' => 10000,
     },

     '/apps/gnumeric/undo/size' => {
	'min' => 1,
	'max' => 1000000
     },

     '/apps/gnumeric/core/defaultfont/size' => {
	 'min' => 1,
	 'max' => 100,
     },

     '/apps/gnumeric/core/gui/screen/horizontaldpi' => {
	 'min' => 10,
	 'max' => 1000,
     },

     '/apps/gnumeric/core/gui/screen/verticaldpi' => {
	 'min' => 10,
	 'max' => 1000,
     },

     '/apps/gnumeric/core/gui/window/x' => {
	 'min' => 0.1,
	 'max' => 1,
     },

     '/apps/gnumeric/core/gui/window/y' => {
	 'min' => 0.1,
	 'max' => 1,
     },

     '/apps/gnumeric/core/gui/window/zoom' => {
	 'min' => 0.1,
	 'max' => 5,
     },

     '/apps/gnumeric/printsetup/hf-font-size' => {
	 'min' => 1,
	 'max' => 100,
     },

     '/apps/gnumeric/printsetup/margin-bottom' => {
	 'min' => 0,
	 'max' => 10000,
     },

     '/apps/gnumeric/printsetup/margin-gtk-bottom' => {
	 'min' => 0,
	 'max' => 720,
     },

     '/apps/gnumeric/printsetup/margin-gtk-left' => {
	 'min' => 0,
	 'max' => 720,
     },

     '/apps/gnumeric/printsetup/margin-gtk-right' => {
	 'min' => 0,
	 'max' => 720,
     },

     '/apps/gnumeric/printsetup/margin-gtk-top' => {
	 'min' => 0,
	 'max' => 720,
     },

     '/apps/gnumeric/printsetup/margin-top' => {
	 'min' => 0,
	 'max' => 10000,
     },

     '/apps/gnumeric/printsetup/scale-percentage-value' => {
	 'min' => 1,
	 'max' => 500,
     },

    );

foreach my $schema (@schemas) {
    my $key = $schema->{'applyto'};
    my $e = $extra_attributes{$key};
    next unless $e;
    foreach my $k (keys %$e) {
	$schema->{$k} = $e->{$k};
    }
}

# -----------------------------------------------------------------------------

foreach my $schema (@schemas) {
    my $i = $schema->{'i'};
    my $var = $schema->{'var'};
    my $key = $schema->{'applyto'};
    my $type = $schema->{'type'};
    $type .= ":" . $schema->{'list_type'} if $type eq 'list';
    my $default = $schema->{'default'};
    my $min = $schema->{'min'};
    my $max = $schema->{'max'};
    my $gtype = ($schema->{'gtype'} || '0');

    my $ctype = $type_to_ctype{$gtype || $type};
    my $ctypes = "$ctype "; $ctypes =~ s/\*\s/\*/;

    $hfile .= "${ctypes}gnm_conf_get_$var (void);\n";
    $hfile .= "void gnm_conf_set_$var ($ctype);\n\n";

    my $get_head = "$ctype\ngnm_conf_get_$var (void)";
    my $set_head = "void\ngnm_conf_set_$var (${ctypes}x)";


    if ($type eq 'bool') {
	$default = uc $default;

	$cfile .= "$get_head\n";
	$cfile .= "{\n";
	$cfile .= "\tconst char *key = \"$key\";\n";
	$cfile .= "\treturn go_conf_load_bool (root, key, $default);\n";
	$cfile .= "}\n\n";

	$cfile .= "$set_head\n";
	$cfile .= "{\n";
	$cfile .= "\tconst char *key = \"$key\";\n";
	$cfile .= "\tgo_conf_set_bool (root, key, x != FALSE);\n";
	$cfile .= "}\n\n";
    } elsif ($type eq 'int' || $type eq 'float') {
	die "$0: No min for $key\n" unless defined $min;
	die "$0: No max for $key\n" unless defined $max;

	$cfile .= "$get_head\n";
	$cfile .= "{\n";
	$cfile .= "\tconst char *key = \"$key\";\n";
	$cfile .= "\treturn go_conf_load_$ctype (root, key, $min, $max, $default);\n";
	$cfile .= "}\n\n";

	$cfile .= "void\n";
	$cfile .= "gnm_conf_set_$var ($ctype x)\n";
	$cfile .= "{\n";
	$cfile .= "\tconst char *key = \"$key\";\n";
	$cfile .= "\tgo_conf_set_$ctype (root, key, CLAMP (x, $min, $max));\n";
	$cfile .= "}\n\n";
    } elsif ($type eq 'string' && $gtype eq '0') {
	$cfile .= "$get_head\n";
	$cfile .= "{\n";
	$cfile .= "\tconst char *key = \"$key\";\n";
	$cfile .= "\tchar *res = go_conf_load_string (root, key, \"$default\");\n";
	$cfile .= "\tg_hash_table_replace (string_pool, key, res);\n";
	$cfile .= "\treturn res;\n";
	$cfile .= "}\n\n";

	$cfile .= "$set_head\n";
	$cfile .= "{\n";
	$cfile .= "\tconst char *key = \"$key\";\n";
	$cfile .= "\tgo_conf_set_string (root, key, x);\n";
	$cfile .= "\tg_hash_table_remove (string_pool, key);\n";
	$cfile .= "}\n\n";
    } elsif ($type eq 'string' && $gtype ne '0') {
	$cfile .= "$get_head\n";
	$cfile .= "{\n";
	$cfile .= "\tconst char *key = \"$key\";\n";
	$cfile .= "\treturn go_conf_load_enum (root, key, $gtype, $default);\n";
	$cfile .= "}\n\n";

	$cfile .= "$set_head\n";
	$cfile .= "{\n";
	$cfile .= "\tconst char *key = \"$key\";\n";
	$cfile .= "\tgo_conf_set_enum (root, key, $gtype, x);\n";
	$cfile .= "}\n\n";
    } elsif ($type eq 'list:string') {
	$cfile .= "$get_head\n";
	$cfile .= "{\n";
	$cfile .= "\tconst char *key = \"$key\";\n";
	$cfile .= "\tGSList *res = go_conf_load_str_list (root, key);\n";
	$cfile .= "\tg_hash_table_replace (string_list_pool, key, res);\n";
	$cfile .= "\treturn res;\n";
	$cfile .= "}\n\n";

	$cfile .= "$set_head\n";
	$cfile .= "{\n";
	$cfile .= "\tconst char *key = \"$key\";\n";
	$cfile .= "\tgo_conf_set_str_list (root, key, x);\n";
	$cfile .= "\tg_hash_table_remove (string_list_pool, key);\n";
	$cfile .= "}\n\n";
    } else {
	die "$0: Unhandled type $type\n";
    }
}

print $hfile;
print $cfile;

# -----------------------------------------------------------------------------

my $schema;
sub walk_tree {
    my ($parents,$contents) = @_;

    if (ref ($contents) eq 'ARRAY') {
	my @items = @$contents;
	my $attrs = shift @items;

	while (@items) {
	    my $tag = shift @items;
	    my $args = shift @items;

	    if ($tag eq '0') {
		# Text
		if (@$parents > 2 && $parents->[-2] eq 'schema') {
		    my $key = $parents->[-1];
		    next if $key eq 'locale';
		    $schema->{$key} = $args;
		}
		if (@$parents > 3 &&
		    $parents->[-3] eq 'schema' &&
		    $parents->[-2] eq 'locale') {
		    my $key = $parents->[-1];
		    next if $key ne 'default';
		    $schema->{$key} = $args;
		}
	    } else {
		$schema = {} if $tag eq 'schema';
		if (@$parents > 1 && $parents->[-1] eq 'schema') {
		    # This handles empty defaults.
		    $schema->{$tag} = '';
		}
		&walk_tree ([@$parents,$tag],$args);
		push @schemas, $schema if $tag eq 'schema';
	    }
	}
    }
}

# -----------------------------------------------------------------------------

__END__

print "static unsigned char key_loaded[$N];\n\n";
print "static const char *key_names[$N] = {\n";
foreach my $schema (@schemas) {
    my $comma = ($schema->{'i'} == $N - 1) ? "" : ",";
    print "\t\"", $schema->{'applyto'}, "\"$comma\n";
}
print "};\n\n";

print "static void\n";
print "load_one_option (int i)\n";
print "{\n";
print "\tconst char *key;\n";
print "\tg_return_if_fail (i >= 0 && i < $N);\n";
print "\n";
print "\tkey = key_names[i];\n";
print "\n";
print "\tswitch (i) {\n";
foreach my $schema (@schemas) {
    my $i = $schema->{'i'};
    my $var = "prefs." . $schema->{'var'};
    my $key = $schema->{'applyto'};
    my $type = $schema->{'type'};
    $type .= ":" . $schema->{'list_type'} if $type eq 'list';
    my $default = $schema->{'default'};

    print "\tcase $i:\n";
    if ($type eq 'bool') {
	$default = uc $default;
	print "\t\t$var =\n";
	print "\t\t\tgo_conf_load_bool (node, key, $default);\n";
    } elsif ($type eq 'int') {
	my $min = 42; # FIXME
	my $max = 42; # FIXME
	print "\t\t$var =\n";
	print "\t\t\tgo_conf_load_int (node, key, $min, $max, $default);\n";
    } elsif ($type eq 'float') {
	my $min = 42; # FIXME
	my $max = 42; # FIXME
	print "\t\t$var =\n";
	print "\t\t\tgo_conf_load_double (node, key, $min, $max, $default);\n";
    } elsif ($type eq 'string') {
	print "\t\tg_free ($var);\n";
	print "\t\t$var =\n";
	print "\t\t\tgo_conf_load_string (node, key);\n";
    } elsif ($type eq 'list:string') {
	print "\t\tgo_slist_free_custom ($var, g_free);\n";
	print "\t\t$var =\n";
	print "\t\t\tgo_conf_load_str_list (node, key);\n";
    } else {
	print "\t\t/* Unhandled type $type */\n";
    }

    print "\t\tbreak;\n";
}
print "\tdefault:\n";
print "\t\tg_assert_not_reached ();\n";
print "\t}\n";
print "\n";
print "\tkey_loaded[i] = TRUE;\n";
print "};\n\n";
