#!/usr/bin/perl -w
# -----------------------------------------------------------------------------

use strict;

$| = 1;

my $myself = $0;
$myself =~ s|^.*/||;

die "$0: must run from top-level gnumeric directory.\n"
    unless -r "gnumeric-config.h.in";
my $dst = "src/tools/solver/lp_solve";

my $lpdir = $ARGV[0];
die "$0: must specify lpsolve directory on command line.\n"
    unless -d $lpdir;

-d $dst or mkdir $dst or
    die "$0: cannot mkdir $dst: $!\n";

my @files =
    (# Header files
     "shared/commonlib.h",
     "lp_types.h",
     "lp_Hash.h",
     "lp_utils.h",
     "lp_matrix.h",
     "lp_SOS.h",
     "lp_mipbb.h",
     "lp_lib.h",
     "lp_crash.h",
     "lp_MPS.h",
     "lp_wlp.h",
     "lp_report.h",
     "lp_scale.h",
     "lp_presolve.h",
     "lp_pricePSE.h",
     "lp_price.h",
     "lp_simplex.h",
     "lp_MDO.h",
     "bfp/bfp_LUSOL/LUSOL/lusol.h",
     "bfp/bfp_LUSOL/lp_LUSOL.h",
     "bfp/lp_BFP.h",
     "bfp/bfp_LUSOL/LUSOL/myblas.h",
     "shared/mmio.h",
     # C files
     "bfp/lp_BFP1.c",
     "bfp/lp_BFP2.c",
     "bfp/bfp_LUSOL/lp_LUSOL.c",
     "bfp/bfp_LUSOL/LUSOL/lusol.c",
     "bfp/bfp_LUSOL/LUSOL/lusol2.c",
     "bfp/bfp_LUSOL/LUSOL/lusol6l0.c",
     "bfp/bfp_LUSOL/LUSOL/lusol6a.c",
     "bfp/bfp_LUSOL/LUSOL/lusol1.c",
     "bfp/bfp_LUSOL/LUSOL/lusol7a.c",
     "bfp/bfp_LUSOL/LUSOL/lusol8a.c",
     "colamd/colamd.h",
     "colamd/colamd.c",
     # "ini.c",
     "shared/commonlib.c",
     "shared/mmio.c",
     "shared/myblas.c",
     "lp_crash.c",
     "lp_Hash.c",
     "lp_lib.c",
     "lp_matrix.c",
     "lp_MDO.c",
     "lp_mipbb.c",
     "lp_MPS.c",
     # "lp_params.c",
     "lp_presolve.c",
     "lp_price.c",
     "lp_pricePSE.c",
     "lp_report.c",
     "lp_scale.c",
     "lp_simplex.c",
     "lp_SOS.c",
     "lp_utils.c",
     "lp_wlp.c",
     );

my $headers = '';

my $dstfile = "$dst/lp_solve.c";
open (DST, ">$dstfile.new") or
    die "$0: Cannot write $dstfile.new: $!\n";
print STDERR "Creating $dstfile...";
print DST "/* Generated by $myself -- do not edit! */\n";
print DST "#include <numbers.h>\n";
print DST "#include <glib.h>\n";
print DST "#include <math.h>\n";
print DST "#include <string.h>\n";
print DST "#include <stdio.h>\n";
print DST "#include <stdlib.h>\n";
print DST "#include <errno.h>\n";
print DST "#include <sys/timeb.h>\n\n";

print DST "#define LoadInverseLib FALSE\n\n";
print DST "#define LoadLanguageLib FALSE\n\n";

foreach my $file (@files) {
    my @defines = ();
    open (SRC, "<$lpdir/$file") or
	die "$0: Cannot read $lpdir/$file: $!\n";
    print DST "/* ", "-" x 73, " */\n";
    print DST "/* Imported $file */\n\n";
    while (<SRC>) {
	next if /^\s*\#\s*include\s*(".*"|<.*>)/;

	next if /^\s*\#\s*define\s+(TRUE|FALSE|MIN|MAX|LoadableBlasLib)\b/;

	s/^(\s*\#\s*define\s+libBLAS\b).*$/$1 0/;
	s/^(\s*\#\s*define\s+STATIC\b).*$/$1 static/;

	if (/^\#\s*ifndef\s+(__BORLANDC__|LLONG|COUNTER|REAL|MAXU?INT(32|64)|MYBOOL|NULL|(BFP|XLI)_CALLMODEL)\b/ ... /^\#\s*endif/) {
	    next;
	}
	if (/^\#\s*ifdef\s+(RoleIsExternalInvEngine|WIN32)\b/ ... /^\#\s*endif/) {
	    next;
	}

	# Crappy intentation forces us to do this.
	next if /^\#\s*ifndef\s+(__WINAPI|CMP_CALLMODEL|BLAS_CALLMODEL)\b/ ... /^$/;

	s/\b(XLI|BFP|BLAS|CMP)_CALLMODEL\s*\b//;
	s/\b__BFP_EXPORT_TYPE\s*\b//g;
	s/\b__EXPORT_TYPE\s*\b//g;
	s/\b__WINAPI\s*\b//;
	s/\b__VACALL\s*\b//;
	s/\bMYBOOL\b/gboolean/g;
	s/\bREAL\b/gnm_float/g;
	s/\bLLONG\b/gint64/g;
	s/\bCOUNTER\b/gint64/g;
	s/\bMAXINT32\b/G_MAXINT32/g;
	s/\bMAXUINT32\b/G_MAXUINT32/g;
	s/\bMAXINT64\b/G_MAXINT64/g;
	s/\bMAXUINT64\b/G_MAXUINT64/g;

	s/\bNZERO\b/MY_NZERO/g; # Avoid clash with /usr/include/limits.h
	s/\bgcd\b/mygcd/g; # Avoid clash with mathfunc.c

	# The API
	s/\bset_(int|timeout|lowbo|upbo|constr_type|maxim|minim|rh|mat|scalelimit)\b/lp_solve_set_$1/g;
	s/\bsolve\b/lp_solve_solve/g;
	s/\b((make|delete|print)_lp)\b/lp_solve_$1/g;
	s/\bget_(total_iter)\b/lp_solve_get_$1/g;
	s/\bget_var_dualresult\b/lp_solve_get_dual/g;
	s/\bget_var_primalresult\b/lp_solve_get_primal/g;
	s/\bget_Nrows\b/lp_solve_get_nrows/g;

	s/\b(malloc)\b/g_malloc/g;
	s/\b(free)\b/g_free/g;
	s/\b(realloc)\b/g_realloc/g;
	s/\b(isspace|tolower|toupper)\b/g_ascii_$1/g;

	s/\bchar\s+\*format\b/const char *format/;
	if (!/\bconst\b/ && /^void\s+blockWrite/) {
	    s/\bchar\s+\*label\b/const char *label/;
	}
	s/^(char\s*\*\s*LUSOL_informstr\b)/const $1/;
	s/\bchar\s+\*method\b/const char *method/;
	if (/\b(bfp_name|BFPchar|LUSOL_pivotLabel|get_str_piv_rule|get_statustext(_func)?|get_str_constr_class|get_str_constr_type|REPORT_modelinfo|REPORT_constraintinfo|stallMonitor_create|write_lpcomment)\b/) {
	    s/\bchar\s+\*/const char */;
	}
	if (/\bstatic\b.*\b(pivotText|informText)\b/) {
	    s/static/static const/;
	}
	if (/^struct _values\b/ ... /^\}/) {
	    s/\bchar\s+\*/const char */;
	}
	if (/^struct _functions\b/ ... /^\}/) {
	    s/\bchar\s+\*/const char */;
	}

	if (/^(char|void|int|gboolean)\b(\s|\*)*(bfp_LUSOL(setcolumn|identity|factorize|tighten)|relationChar|HUP|HDOWN|HINSERT|HCHANGE|HDELETE|HBUILD|LU[167][a-zA-Z0-9_]+|QS_(validate|updatelink|sort|finish)|clean_realloc|LUSOL_realloc_a|LUSOL_expand_a|LUSOL_realloc_r|LUSOL_realloc_c|invert|debug_print|debug_print_solution|debug_print_bounds)\b/) {
	    s/^/static /;
	    s/^static static/static /;
	}

	next if /read_params/;
	next if /write_params/;
	next if /read_LPhandle/;

	if (/^((STATIC|static|INLINE)\s+)?(char|void|int|gboolean|gnm_float|PVrec|BBrec|MATrec)\b(\s|\*)*(freePackedVector|vec_compress|compareLink|mat_setitem|prod_Ax|set_dv_bounds|get_dv_lower|get_dv_upper|print_indent|allocFREE|set_bitoff|normalizeVector|chsign_bounds|sizeLink|countActiveLink|prevInactiveLink|verifyLink|createPackedVector|pushPackedVector|unpackPackedVector|getvaluePackedVector|popPackedVector|mat_extractmat|mat_indexrange|mat_equalRows|mat_additem|mat_mergemat|mat_matinsert|vec_expand|fimprove|findself_BB|check_if_less|verify_solution|is_slackbasis|validate_bounds|varmap_validate|varmap_addcolumn|varmap_addconstraint|set_OF_override|guess_basis|debug_print|debug_print_solution|debug_print_bounds|verifyPricer|update_reducedcosts|partial_activeBlocks|partial_blockNextPos|partial_isVarActive|multi_size|multi_valueList|multi_getvar|LU1MCP|QS_updatelink|compute_violation|isPrimalSimplex|isPhase1|isDegenerateBasis|findNonBasicSlack|replaceBasisVar|mat_findcolumn|verifyMDO|probe_BB|presolve_BB|presolve_mustupdate|presolve_debugmap|presolve_debugcheck|presolve_rowlengthdebug|presolve_rowfix|presolve_probetighten01|presolve_invalideq2|presolve_debugdump|longdual_testset|stallMonitor_creepingObj|stallMonitor_shortSteps|findBasicArtificial)\b/ .. (/^\}/ || /^[A-Za-z].*;$/)) {
	    next;
	}

	if ($file =~ /\.c$/ && /^\s*\#\s*define\s+([a-zA-Z_0-9]+)/) {
	    push @defines, $1;
	}

	if (/^(void|int|gint64|gboolean|gnm_float|lprec\s*\*)\s+lp_solve_\S+\s*\(.*\)\s*;$/ ||
	    /^typedef\b.*\blprec;$/ ||
	    /^\#define\s*ROWTYPE_(LE|GE|EQ)\b/ ||
	    (m{^/\* Solver status values \*/} ... /^$/)) {
	    $headers .= $_;
	}

	print DST;
    }
    close (SRC);
    if (@defines) {
	print DST "/* Cleaning up after import of $file */\n";
	foreach my $sym (@defines) {
	    print DST "#undef $sym\n";
	}
    }
}
close (DST);
&update_file ($dstfile);


{
    my $dstfile = "$dst/lp_solve.h";
    open (DST, ">$dstfile.new") or
	die "$0: Cannot write $dstfile.new: $!\n";
    print STDERR "Creating $dstfile...";
    print DST "/* Generated by $myself -- do not edit! */\n";
    print DST "#ifndef LP_SOLVE_H\n";
    print DST "#define LP_SOLVE_H\n";
    print DST "#include <glib.h>\n";
    print DST "#include <numbers.h>\n";
    print DST $headers;
    print DST "#endif\n";
    close (DST);
    &update_file ($dstfile);
}

# -----------------------------------------------------------------------------

sub update_file {
    my ($old) = @_;
    my ($new) = "$old.new";

    if (!-r $old) {
	rename $new, $old or
	    die "$0: Cannot rename $new to $old: $!\n";
	print STDERR " -- done.\n";
    } else {
	system ("cmp '$old' '$new' >/dev/null");
	if ($? == 0) {
	    print STDERR " -- unchanged.\n";
	    unlink $new;
	} else {
	    rename $new, $old or
		die "$0: Cannot rename $new to $old: $!\n";
	    print STDERR " -- done.\n";
	}
    }
}

# -----------------------------------------------------------------------------
